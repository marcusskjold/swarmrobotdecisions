<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>

//// ================================================
//// Constants and type definition

// Maximally connected network
/*
const int R = 7;                       // Number of robots
const int Q = 4;                       // Number of choices
const int NN = 6;                      // Max number of neighbors
const double empirical = 0.5;

bool C[R][R] = {{false, true, true, true, true, true, true},
               {true, false, true, true, true, true, true},
               {true, true, false, true, true, true, true},
               {true, true, true, false, true, true, true},
               {true, true, true, true, false, true, true},
               {true, true, true, true, true, false, true},
               {true, true, true, true, true, true, false}};
*/

// Test network - medium size
/*
const int Q = 10;
const int R = 10;
const int NN = 4;
const double empirical = 10.0;
bool C[R][R] = {{false, true, true, true, false, false, false, false, true, false}, {true, false, true, false, false, false, true, true, false, false}, {true, true, false, true, true, false, false, false, false, false}, {true, false, true, false, true, true, false, false, false, false}, {false, false, true, true, false, true, false, false, true, false}, {false, false, false, true, true, false, true, false, false, false}, {false, true, false, false, false, true, false, true, false, true}, {false, true, false, false, false, false, true, false, true, true}, {true, false, false, false, true, false, false, true, false, true}, {false, false, false, false, false, false, true, true, true, false}};
*/


// Minimally connected network of 7
/*
const int R = 7;                       // Number of robots
const int Q = 4;                       // Number of choices
const int NN = 2;                      // Max number of neighbors
const double empirical = 0.01;

bool C[R][R] = {{false, true, false, false, false, false, false},
               {true, false, true, false, false, false, false},
               {false, true, false, true, false, false, false},
               {false, false, true, false, true, false, false},
               {false, false, false, true, false, true, false},
               {false, false, false, false, true, false, true},
               {false, false, false, false, false, true, false}};
*/


// Minimally connected network of 20
/*
const int R = 20;                       // Number of robots
const int Q = 4;                       // Number of choices
const int NN = 2;                      // Max number of neighbors
const double empirical = 0.01;

bool C[R][R] = {{false, true,  false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
                {true,  false, true,  false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
                {false, true,  false, true,  false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
                {false, false, true,  false, true,  false, false, false, false, false, false, false, false, false, false, false, false, false, false, false},
                {false, false, false, true,  false, true,  false, false, false, false, false, false, false, false, false, false, false, false, false, false},
                {false, false, false, false, true,  false, true,  false, false, false, false, false, false, false, false, false, false, false, false, false},
                {false, false, false, false, false, true,  false, true,  false, false, false, false, false, false, false, false, false, false, false, false},
                {false, false, false, false, false, false, true,  false, true,  false, false, false, false, false, false, false, false, false, false, false},
                {false, false, false, false, false, false, false, true,  false, true,  false, false, false, false, false, false, false, false, false, false},
                {false, false, false, false, false, false, false, false, true,  false, true,  false, false, false, false, false, false, false, false, false},
                {false, false, false, false, false, false, false, false, false, true,  false, true,  false, false, false, false, false, false, false, false},
                {false, false, false, false, false, false, false, false, false, false, true,  false, true,  false, false, false, false, false, false, false},
                {false, false, false, false, false, false, false, false, false, false, false, true,  false, true,  false, false, false, false, false, false},
                {false, false, false, false, false, false, false, false, false, false, false, false, true,  false, true,  false, false, false, false, false},
                {false, false, false, false, false, false, false, false, false, false, false, false, false, true,  false, true,  false, false, false, false},
                {false, false, false, false, false, false, false, false, false, false, false, false, false, false, true,  false, true,  false, false, false},
                {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true,  false, true,  false, false},
                {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true,  false, true,  false},
                {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true,  false, true},
                {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true,  false}};
*/

// Minimally connected network of 10
/* Edge cases appear here, where one robot ends up not registering that it has a full decision group,
while every other robot does, and so they end up in the terminal state, and the final robot gets stuck.
Our theory is that this is because a robot with only one neighbor has bad access to information.
The problem is easily fixed by adding a check for robots being done. */
/*
const int R = 10;                       // Number of robots
const int Q = 4;                       // Number of choices
const int NN = 2;                      // Max number of neighbors

bool C[R][R] = {{false, true, false, false, false, false, false, false, false, false},
                {true, false, true, false, false, false, false, false, false, false},
                {false, true, false, true, false, false, false, false, false, false},
                {false, false, true, false, true, false, false, false, false, false},
                {false, false, false, true, false, true, false, false, false, false},
                {false, false, false, false, true, false, true, false, false, false},
                {false, false, false, false, false, true, false, true, false, false},
                {false, false, false, false, false, false, true, false, true, false},
                {false, false, false, false, false, false, false, true, false, true},
                {false, false, false, false, false, false, false, false, true, false}};
*/

// Circular network of 10
/* The edge cases described (2025-04-30) do not appear.
This supports our theory that the edge cases only appear for robots with just one neighbor.
*/
/*
const int R = 10;                       // Number of robots
const int Q = 4;                       // Number of choices
const int NN = 2;                      // Max number of neighbors
const double empirical = 0.5;

bool C[R][R] = {{false, true, false, false, false, false, false, false, false, true},
                {true, false, true, false, false, false, false, false, false, false},
                {false, true, false, true, false, false, false, false, false, false},
                {false, false, true, false, true, false, false, false, false, false},
                {false, false, false, true, false, true, false, false, false, false},
                {false, false, false, false, true, false, true, false, false, false},
                {false, false, false, false, false, true, false, true, false, false},
                {false, false, false, false, false, false, true, false, true, false},
                {false, false, false, false, false, false, false, true, false, true},
                {true, false, false, false, false, false, false, false, true, false}};
*/

// Large random graph similar to paper

const int Q = 10;
const int R = 30;
const int NN = 6;
const double empirical = 0;

bool C[R][R] = {{false, true, false, false, false, false, false, false, true, true, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, true, false, true, false}, {true, false, true, false, false, false, false, true, false, false, false, false, false, true, false, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false}, {false, true, false, true, false, true, false, false, false, false, false, false, false, false, false, true, true, false, true, false, false, false, false, false, false, false, false, false, false, false}, {false, false, true, false, true, false, false, true, true, false, false, false, false, false, false, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false}, {false, false, false, true, false, true, false, false, false, false, true, true, false, true, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false}, {false, false, true, false, true, false, true, true, false, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}, {false, false, false, false, false, true, false, true, false, false, false, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}, {false, true, false, true, false, true, true, false, true, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}, {true, false, false, true, false, false, false, true, false, true, false, false, true, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, false}, {true, false, false, false, false, true, false, false, true, false, true, true, false, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}, {false, false, false, false, true, true, false, false, false, true, false, true, false, false, false, false, false, false, false, true, false, false, true, false, false, false, false, false, false, false}, {false, false, false, false, true, false, true, true, false, true, true, false, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false}, {false, false, false, false, false, false, true, false, true, false, false, true, false, true, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, false}, {false, true, false, false, true, false, true, false, false, false, false, false, true, false, true, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false}, {false, false, false, false, false, false, true, false, false, true, false, false, false, true, false, true, false, false, false, false, true, false, false, false, true, false, false, false, false, false}, {false, true, true, true, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, false, false, true, false, false, false, false, false, false, false}, {false, true, true, true, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, true, false, false, false, false, false, false, false, false}, {false, false, false, false, true, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, false, false, true, false, false, false, false, false, false, false}, {false, false, true, false, false, false, false, false, false, false, false, false, true, false, false, false, false, true, false, true, true, true, false, false, false, false, false, false, false, false}, {false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, true, false, true, true, false, true, false, false, false, true, false, false}, {false, false, false, false, false, false, false, false, true, false, false, false, true, false, true, false, false, false, true, true, false, true, false, false, false, false, false, false, false, false}, {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, true, true, false, true, true, false, false, false, false, false, false}, {true, false, false, false, false, false, false, false, false, false, true, false, false, false, false, true, false, true, false, false, false, true, false, true, false, false, false, false, false, false}, {false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, true, false, true, true, false, true, true, false, false, false, false}, {false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, false, false, false, false, true, false, true, true, true, false, true}, {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, false, true, false, true, false}, {true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, false, true, false, true}, {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, false, false, false, true, false, true, false, true, false}, {true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, true}, {false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, false, true, false, true, false}};


//// ========================================

typedef int[0,NN-1] neighbor;          // The set of possible neighbor indexes
typedef int[-1,NN-1] optionalNeighbor; // The set of possible neighbor indexes, -1 denoting null
typedef int[0,2] timestamp;            // Synchronization following rock-paper-scissors logic ( 0 &lt; 1 &lt; 2 &lt; 0 )
typedef int[0,Q-1] choice;             // The set of choice indexes
typedef int[-1,Q-1] optionalChoice;    // The set of choice indexes
typedef int[0,R-1] robot;              // The set of robot ids
typedef int[-1,R-1] optionalRobot;     // The set of robot ids, -1 denoting null
typedef int[0,3] calmness; // TODO Remove
typedef int[0,R+1] levels;

//// ================================================
//// Robot state

/* Most state is kept in global variables. 
However, a robot only ever accesses the state of its neighbors. 
In this we abstract away the specific communication protocal, while maintaining the requirement that robots have no global knowledge. */


/* The public decision of each robot. Is updated (along P), after publicP and ND but before any neighbor starts recalculating D */
choice decision[R];

/*The decision group of each robot - true means the robot of that ID is in the same group. Is continuously updated while in the calculateDsize state*/
bool D[R][R];

/* The public preferences of each robot - the preferences are only updated simultaneously with ND */
double publicP[R][Q];

/* The public size of the donsensus group of each robot. 
Is updated atomically, after having calculated D.
The paper calls this the consensus group, we call it the [D]ecision group 
This is to phonetically align the use of C and D for neighbors (connected robots) and consenting (same decision) respectively.*/
int[0,R] ND[R];

/* The reason why some fields are updated atomically and others continuously is because they are used for different purposes:
publicP and ND are used when updating neighboring robots preferences, and so they should represent the last coherent state.
D is used for propagating information to calculate ND, and so it updates continuously.
decision is determined right after P is updated. */

// Locking state
timestamp cycle[R];         // Used to synchronize cyclus.
levels level[R];        // Synchronization while calculating D.
levels thresh[R]; 
bool calm[R];               // Used for determining when D has been calculated. Inactive
robot updateDegree[R];

//// =================================================
//// Functions

// Timestamps

// Returns true if the timestamp of robot a is behind or at equal to that of robot b. False if a is in front.
bool compareTimestamps(timestamp a, timestamp b) {
    if (a == b) return true;
    if ((a + 1) % 3 == b) return true;
    return false;
}

// Populate array with random values summing to 1 (PMF)
void initP(double &amp;P[Q]){
    double rands[Q];
    double ssum = 0;
    for (i : choice) {
        double val = random(1);
        rands[i] = val;
        ssum = ssum + val;
    }
    for (i : choice) {
        P[i] = rands[i] / ssum;
    }
}

// Count the number of true values in array
int[0,R] count(bool &amp;A[R]){
    return sum (i : robot) A[i] == true;
}

bool isSubsetOf(bool &amp;A[R], bool &amp;B[R]) {
    return forall (r : robot) A[r] imply B[r];
}

// Get the index of a highest value
choice maxIndex(double &amp;P[Q]){
    choice maxI = 0;
    double max = 0;
    for (i : choice){
        if (P[i] &gt; max) {
            max = P[i];
            maxI = i;
        }
    }
    return maxI;
}

// Get next true value of boolean array A *after* index i.
// Returns -1 if there is no next value
optionalRobot getNextTrue(int i, bool &amp;A[R]){
    while (i &lt; R-1) {
        i++;
        if (A[i]) return i;
        
    }
    return -1;
}

//// ================================================
//// Meta

// Return true if all values are equal. Used for verification
bool allSameTimestamp(timestamp &amp;A[R]){
    timestamp comparison = A[0];
    return forall (i : int[1,R-1]) A[i] == comparison;
}

// Have a robot finished
bool done[R];
bool allDone = false;
bool sameCycle = false;
clock x = 0;
int cyclecounter[R];</declaration>
	<template>
		<name>Robot</name>
		<parameter>robot id</parameter>
		<declaration>//// =====================================================
//// State

optionalRobot neighbors[NN];           // Inverted index of neighbors, index 0 to count(C)-1 contains index of true values in C. -1 for empty slots.
bool mayContinue;                      // Guard and synchronization variable - is updated with compareCycle() and compareLevels()
double P[Q];                           // Preferences as a PMF over all choices in Q.
bool wasUpdated;
choice s[Q];
double divergence;


// Debug
bool watchDiv = false;
bool watchLl = false;
bool watchLu = false;
bool watchResult = false;

//// =====================================================
//// Methods
// Functions that are simplified by having access to state

    //// Utility

bool isInSameCycle(robot r)      { return cycle[r] == cycle[id]; }
bool isConsenting(robot r)       { return decision[r] == decision[id]; }
bool isRobot(optionalRobot r)    { return r != -1; }
bool isCalm(robot r)             { return calm[r]; }
bool isLowerLevel(robot r)       { return level[r] &lt; level[id]; }
bool isInEarlierCycle(robot r)   { return !compareTimestamps(cycle[id], cycle[r]); }
bool isInNextCycle(robot r)      { return !compareTimestamps(cycle[r], cycle[id]); }
bool isDone(robot r)             { return done[r]; }
void incrementLevel()            { level[id] = level[id] + 1; }

/**Increment cycle by one and reset lower synchronization variables*/
void incrementCycle()            { 
    cycle[id] = (cycle[id] + 1) % 3; 
    level[id] = 0;
    calm[id] = false;
    cyclecounter[id] = cyclecounter[id] + 1;
}


    //// Synchronization methods

/**Returns true if the all neighbors are on the same as self.*/
bool compareCycle() {
    optionalRobot r;

    for (n : neighbor) {
        r = neighbors[n];
        if (isRobot(r) &amp;&amp; !isInSameCycle(r)) { return false; }
    }
    return true;

}

/**Returns true if no consenting neighbor is behind this robot in updating their D array.*/
/* This ensures that the robot does not ask a neighbor twice before that neighbor has a chance to update their values.
A neighbor can never be in an earlier cycle than this robot when compareLevels() is called.
This is because compareLevelsConsenting is only called in state `FindingDecisionGroup`.
Cycles are only incremented when entering state `AwaitingNeighbors`, and `AwaitingNeighbors` can only be exited when all neighbors are in the same or next cycle*/
bool compareLevelsConsenting() {
    optionalRobot r;

    for (n : neighbor) {
        r = neighbors[n];
        if (isRobot(r) &amp;&amp; isConsenting(r) &amp;&amp; isInSameCycle(r) &amp;&amp; isLowerLevel(r) &amp;&amp; !isDone(r)) {  return false; }
    }
    return true;
}

/**Returns true if every neighbor has updated their preference.*/
/* This ensures that the robot does not start calculating their Decision groups based on outdated information.
A neighbor can never be in an earlier cycle than this robot when compareLevels() is called.
This is because compareLevels is only called in state `PreferencesUpdated`.
Cycles are only incremented when entering state `AwaitingNeighbors`, and `AwaitingNeighbors` can only be exited when all neighbors are in the same or next cycle*/
bool compareLevels() {
    optionalRobot r;

    for (n : neighbor) {
        r = neighbors[n];
        if (isRobot(r) &amp;&amp; isInSameCycle(r) &amp;&amp; isLowerLevel(r) &amp;&amp; !isDone(r)) {  return false; }
    }
    return true;
}


/**Returns true if no consenting, updating, neighbor has a calmness of 0.*/
/* As this method is only colled when this robots calmness is 1, it works like a comparison, asking: are all eligible neighbors at the same or highe level of calmness?*/
/* TODO : UPDATE TEXT */
bool compareCalmness() {
    optionalRobot r;

    for (n : neighbor) {
        r = neighbors[n];
        if (isRobot(r) &amp;&amp; isConsenting(r) &amp;&amp; isInSameCycle(r) &amp;&amp; !isDone(r) &amp;&amp; (isLowerLevel(r) || !isCalm(r))) { return false; }
    }
    return true;
}

    //// Updating and calculating preferences (P)

void sortPreferences(){
    bool mask[Q];
    for (c : choice) { mask[c] = true;}
    for (c : choice) {
        double maxV;
        choice maxI;
        for (d : choice) {
            if (mask[d] &amp;&amp; P[d] &gt; maxV) { 
                maxV = P[d]; 
                maxI = d;
            }
        }
        mask[maxI] = false;
        s[maxI] = c;
    }
    return;
}

bool isLocallyConverged() {
    double max = 0;
    double temp;
    int[0,R] r;
    int[0,R] t;
    if (!isSubsetOf(C[id], D[id])){ return false; }
    for (r = 0; r &lt; R; r++) {
        for (t = r+1; t &lt; R; t++) {
            temp = 0;
            for (c : choice) {
                temp = temp + fabs(publicP[r][c] - publicP[t][c]);
            }
            if (temp &gt; max) { max = temp; }
        }
    }
    divergence = max;
    if (divergence == 0) { watchDiv = true; }
    return max &lt; empirical;
}

double L(choice rank) {
    const double n = Q - 1;
    double rankF = rank;                                              // An int between 0 &amp; n, smaller should give higher result
    double Ll = (1.0 / n+1.0) * pow((divergence / empirical), 0.3);   // A number between 0 &amp; 1/Q
    double Lu = (2.0 / n+1.0) - Ll;                                   // A number between 1/Q &amp; 2/Q
    double result = (Ll * (rankF / n)) + (Lu * ((n - rank) / n));     
    if (Ll == 0) { watchLl = true; }
    if (Lu == 0) { watchLu = true; }
    if (result == 0) { watchResult = true; }
    return result;
}

void accelerateConvergence() {
    double psum = 0.0;
    sortPreferences();
    for (c : choice) {
        P[c] = P[c] * L(s[c]);
        psum = psum + P[c];
    }
    for (c : choice) {
        P[c] = (P[c] / psum);
    }

}

/**Updates the preferences of this robot according to the equation given in (Liu &amp; Lee, 2020)*/
/* Uses the last coherent state of each neighbor.*/
void updateP() {
    double sumP[Q];    // The sum of all neighbor's preference value for each choice (including self)
    int sumND;         // The total size of all neighbor's decision groups (including self)
    optionalRobot r;

    // First add yourself
    for (c : choice) {
                sumP[c] = sumP[c] + ND[id] * publicP[id][c];
    }
    sumND += ND[id];

    // Then add the each neighbor
    for (n : neighbor) {
        r = neighbors[n];
        if ( isRobot(r) ) {
            for (c : choice) {
                sumP[c] = sumP[c] + ND[r] * publicP[r][c];
            }
            sumND += ND[r];
        }
    }

    // Normalize
    for (c : choice) { P[c] = sumP[c] / sumND; } 
    
    // Determine local convergence
    if (isLocallyConverged()) {
        accelerateConvergence();
    }
}

    //// Calculating consensus / decision group (D)

/** Add every robot to the decision group (D) of this robot that are present in the decision group of any neighbors with the same decision as this.
The function returns true if no new robots were added. */
bool syncWithConsentingNeighbors() {
    bool stale = true;
    optionalRobot r;

    for (n : neighbor) {
        r = neighbors[n];
        if (isRobot(r) &amp;&amp; isConsenting(r)) {
            for (s : robot) {
                stale &amp;= (D[r][s] imply D[id][s]);  // Information is only new if the neighbor knows of an id that is in the group that this robot does not.
                D[id][s] = D[r][s] || D[id][s];     // Union operation
            }

        }
    }
    ND[id] = count(D[id]);
    return stale;
}

void evaluateCalmness() {
    if (wasUpdated) { calm[id] = 0; }
    else if (calm[id] &lt; 2) { calm[id] = calm[id] + 1; }
    else if (compareCalmness()) { calm[id] = 3; }
    else { calm[id] = 2; }
}

void updateThresh() {
    int x = level[id] + updateDegree[id];
    if (thresh[id] == R) {return;}
    
    if (x &gt; R) {x = R;}
    if (x &gt; thresh[id]) {thresh[id] = x;}
}

    //// Initializations

// Resets the D array. 
void resetD() {
    for (r : robot) { D[id][r] = false; }
    D[id][id] = true;                      // A robot always agrees with itself
    ND[id] = 1;
}

// Create inverted Index of neighbors (neighbors array)
void initNeighbors() {
    optionalRobot nextNeighbor;
    nextNeighbor = getNextTrue(-1, C[id]);                    // Find first neighboring robot

    for (n : neighbor) {
        if (isRobot(nextNeighbor)) {
            neighbors[n] = nextNeighbor;                  // Save neighbor in neighbors
            nextNeighbor = getNextTrue(nextNeighbor, C[id]);  // Find next neighboring robot
        } else {
            neighbors[n] = -1;                            // If there are no more neighbors
        }
    }
}

// Initialize a robot with random preferences.
void initialize() {
    initP(P);
    decision[id] = maxIndex(P);
    initNeighbors();
    level[id] = 0;
    cycle[id] = 0;
    resetD();
    level[id] = 1;
    mayContinue = false;
    // Meta values
    cyclecounter[id] = 0;
    allDone = false;
    done[id] = false;
    x = 0;
    sameCycle = false;
}

</declaration>
		<location id="id0" x="-280" y="-289">
			<name x="-263" y="-306">Initial</name>
			<label kind="exponentialrate" x="-306" y="-297">1</label>
			<urgent/>
		</location>
		<location id="id1" x="-178" y="-212">
			<name x="-144" y="-221">PreferencesUpdated</name>
			<label kind="exponentialrate" x="-178" y="-221">1</label>
		</location>
		<location id="id2" x="187" y="-85">
			<name x="204" y="-110">FindingDecisionGroup</name>
			<label kind="exponentialrate" x="187" y="-93">1</label>
		</location>
		<location id="id3" x="187" y="-331">
			<name x="204" y="-357">AwaitingNeighbors</name>
			<label kind="exponentialrate" x="187" y="-340">1</label>
		</location>
		<location id="id4" x="756" y="-331">
			<name x="746" y="-365">Terminal</name>
			<label kind="exponentialrate" x="748" y="-340">1</label>
		</location>
		<init ref="id0"/>
		<transition id="id5">
			<source ref="id1"/>
			<target ref="id1"/>
			<label kind="guard" x="-340" y="-238">!mayContinue</label>
			<label kind="assignment" x="-484" y="-221">mayContinue = compareLevels()</label>
			<nail x="-238" y="-238"/>
			<nail x="-238" y="-187"/>
		</transition>
		<transition id="id6">
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="guard" x="408" y="-348">ND[id] == R</label>
			<label kind="assignment" x="408" y="-331">done[id] = true,
allDone = count(done) == R ? 1 : 0,
sameCycle = allSameTimestamp(cycle)</label>
			<label kind="comments" x="408" y="-272">These updates are only for verification (SMC)</label>
		</transition>
		<transition id="id7">
			<source ref="id3"/>
			<target ref="id3"/>
			<label kind="guard" x="102" y="-416">!mayContinue &amp;&amp; ND[id] != R</label>
			<label kind="assignment" x="110" y="-399">mayContinue = compareCycle()</label>
			<nail x="204" y="-374"/>
			<nail x="170" y="-374"/>
		</transition>
		<transition id="id8">
			<source ref="id3"/>
			<target ref="id1"/>
			<label kind="guard" x="-136" y="-399">mayContinue &amp;&amp; ND[id] != R</label>
			<label kind="assignment" x="-136" y="-382">updateP(),
decision[id] = maxIndex(P),
resetD(),
level[id] = 1,
mayContinue = false</label>
		</transition>
		<transition id="id9">
			<source ref="id2"/>
			<target ref="id3"/>
			<label kind="guard" x="195" y="-221">level[id] &gt; ND[id]</label>
			<label kind="assignment" x="195" y="-204">publicP[id] = P,
mayContinue = false,
incrementCycle()</label>
			<nail x="187" y="-102"/>
		</transition>
		<transition id="id10">
			<source ref="id2"/>
			<target ref="id2"/>
			<label kind="guard" x="187" y="-59">!mayContinue &amp;&amp; level[id] &lt;= ND[id]</label>
			<label kind="assignment" x="187" y="-42">mayContinue = compareLevelsConsenting()</label>
			<nail x="187" y="-17"/>
			<nail x="136" y="-17"/>
			<nail x="136" y="-85"/>
		</transition>
		<transition id="id11">
			<source ref="id2"/>
			<target ref="id2"/>
			<label kind="guard" x="170" y="0">mayContinue &amp;&amp; level[id] &lt;= ND[id]</label>
			<label kind="assignment" x="170" y="17">syncWithConsentingNeighbors(),
incrementLevel(),
mayContinue = false</label>
			<nail x="535" y="-85"/>
			<nail x="535" y="17"/>
			<nail x="136" y="17"/>
			<nail x="136" y="-85"/>
		</transition>
		<transition id="id12">
			<source ref="id1"/>
			<target ref="id2"/>
			<label kind="guard" x="8" y="-178">mayContinue</label>
			<label kind="assignment" x="8" y="-161">mayContinue = false</label>
		</transition>
		<transition id="id13">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="assignment" x="-255" y="-289">initialize()</label>
		</transition>
	</template>
	<system>system Robot;
</system>
	<queries>
		<option key="--diagnostic" value="-1"/>
		<query>
			<formula>E[&lt;=10000; 100](max: cyclecounter[0])</formula>
			<comment>How many cycles in total does robot 0 go through before consensus is reached.

Results:
For 7 robots with random preferences in a fully connected graphs. [&lt;=1000;5000] ≈ 2 (as expected)</comment>
			<option key="--diagnostic" value="0"/>
			<result outcome="success" type="quantity" value="5.85 ± 0.305544 (95% CI)" timestamp="2025-05-09 11:07:13 +0200">
				<option key="--diagnostic" value="0"/>
				<details>5.85 ± 0.305544 (95% CI)</details>
				<plot title="Probability Density Distribution" xaxis="max: cyclecounter[0]" yaxis="probability density">
					<series title="density" type="b(1.000000)" color="0x0000ff" encoding="csv">4.0,0.15
5.0,0.38
6.0,0.2
7.0,0.13
8.0,0.06
9.0,0.05
10.0,0.02
11.0,0.01
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">5.85,0.0
5.85,0.38
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=8
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [4, 11]
Mean estimate of displayed sample: 5.85 ± 0.3055 (95% CI)</comment>
				</plot>
				<plot title="Probability Distribution" xaxis="max: cyclecounter[0]" yaxis="probability">
					<series title="probability" type="b(1.000000)" color="0x0000ff" encoding="csv">4.0,0.15
5.0,0.38
6.0,0.2
7.0,0.13
8.0,0.06
9.0,0.05
10.0,0.02
11.0,0.01
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">5.85,0.0
5.85,0.38
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=8
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [4, 11]
Mean estimate of displayed sample: 5.85 ± 0.3055 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Distribution" xaxis="max: cyclecounter[0]" yaxis="probability">
					<series title="cumulative" type="l" color="0x000000" encoding="csv">4.0,0.0
5.0,0.15
6.0,0.53
7.0,0.73
8.0,0.86
9.0,0.92
10.0,0.97
11.0,0.99
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">5.85,0.0
5.85,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=8
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [4, 11]
Mean estimate of displayed sample: 5.85 ± 0.3055 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Confidence Intervals" xaxis="max: cyclecounter[0]" yaxis="probability">
					<series title="upper limit" type="k" color="0x0000dd" encoding="csv">4.0,0.03621669264517642
5.0,0.23530750014895488
6.0,0.6305948358056055
7.0,0.8139335777092593
8.0,0.9212945950730342
9.0,0.9648284374818372
10.0,0.9937700284616936
11.0,0.9997468539670226
					</series>
					<series title="lower limit" type="k" color="0xdd0000" encoding="csv">4.0,0.0
5.0,0.08645438564164858
6.0,0.4275814848900451
7.0,0.6319837270910251
8.0,0.7762720186294323
9.0,0.848442364135579
10.0,0.91482394702572
11.0,0.9455406146079194
					</series>
					<series title="cumulative" type="l" color="0x000000" encoding="csv">4.0,0.0
5.0,0.15
6.0,0.53
7.0,0.73
8.0,0.86
9.0,0.92
10.0,0.97
11.0,0.99
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">5.85,0.0
5.85,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=8
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [4, 11]
Mean estimate of displayed sample: 5.85 ± 0.3055 (95% CI)</comment>
				</plot>
				<plot title="Frequency Histogram" xaxis="max: cyclecounter[0]" yaxis="count">
					<series title="count" type="b(1.000000)" color="0x0000ff" encoding="csv">4.0,15.0
5.0,38.0
6.0,20.0
7.0,13.0
8.0,6.0
9.0,5.0
10.0,2.0
11.0,1.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">5.85,0.0
5.85,38.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=1, bucket count=8
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [4, 11]
Mean estimate of displayed sample: 5.85 ± 0.3055 (95% CI)</comment>
				</plot>
			</result>
		</query>
		<query>
			<formula>E[&lt;=10000; 100](max: x * (allDone ? 0 : 1) )</formula>
			<comment/>
			<result outcome="success" type="quantity" value="538.828 ± 36.0652 (95% CI)" timestamp="2025-05-09 10:54:20 +0200">
				<option key="--diagnostic" value="-1"/>
				<details>538.828 ± 36.0652 (95% CI)</details>
				<plot title="Probability Density Distribution" xaxis="max: x * (allDone ? 0 : 1)" yaxis="probability density">
					<series title="density" type="b(102.993181)" color="0x0000ff" encoding="csv">300.73666545559195,0.00213606374051758
403.72984671089137,0.0027186265788405567
506.7230279661908,0.00213606374051758
609.7162092214902,0.0013593132894202783
712.7093904767896,5.825628383229764E-4
815.702571732089,4.854690319358137E-4
918.6957529873885,0.0
1021.6889342426879,9.709380638716273E-5
1124.6821154979873,9.709380638716273E-5
1227.6752967532866,9.709380638716273E-5
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">538.8280320206784,0.0
538.8280320206784,0.0027186265788405567
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=102.99, bucket count=10
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [300.7, 1331]
Mean estimate of displayed sample: 538.8 ± 36.07 (95% CI)</comment>
				</plot>
				<plot title="Probability Distribution" xaxis="max: x * (allDone ? 0 : 1)" yaxis="probability">
					<series title="probability" type="b(102.993181)" color="0x0000ff" encoding="csv">300.73666545559195,0.22
403.72984671089137,0.28
506.7230279661908,0.22
609.7162092214902,0.14
712.7093904767896,0.06
815.702571732089,0.05
918.6957529873885,0.0
1021.6889342426879,0.01
1124.6821154979873,0.01
1227.6752967532866,0.01
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">538.8280320206784,0.0
538.8280320206784,0.28
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=102.99, bucket count=10
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [300.7, 1331]
Mean estimate of displayed sample: 538.8 ± 36.07 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Distribution" xaxis="max: x * (allDone ? 0 : 1)" yaxis="probability">
					<series title="cumulative" type="l" color="0x000000" encoding="csv">300.73666545559195,0.0
403.72984671089137,0.22
506.7230279661908,0.5
609.7162092214902,0.72
712.7093904767896,0.86
815.702571732089,0.92
918.6957529873885,0.97
1021.6889342426879,0.97
1124.6821154979873,0.98
1227.6752967532866,0.99
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">538.8280320206784,0.0
538.8280320206784,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=102.99, bucket count=10
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [300.7, 1331]
Mean estimate of displayed sample: 538.8 ± 36.07 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Confidence Intervals" xaxis="max: x * (allDone ? 0 : 1)" yaxis="probability">
					<series title="upper limit" type="k" color="0x0000dd" encoding="csv">300.73666545559195,0.03621669264517642
403.72984671089137,0.31391965378631786
506.7230279661908,0.601678870496699
609.7162092214902,0.8052063725088185
712.7093904767896,0.9212945950730342
815.702571732089,0.9648284374818372
918.6957529873885,0.9937700284616936
1021.6889342426879,0.9937700284616936
1124.6821154979873,0.9975686631760574
1227.6752967532866,0.9997468539670226
					</series>
					<series title="lower limit" type="k" color="0xdd0000" encoding="csv">300.73666545559195,0.0
403.72984671089137,0.14330357674981448
506.7230279661908,0.398321129503301
609.7162092214902,0.6213329952827324
712.7093904767896,0.7762720186294323
815.702571732089,0.848442364135579
918.6957529873885,0.91482394702572
1021.6889342426879,0.91482394702572
1124.6821154979873,0.9296160675289299
1227.6752967532866,0.9455406146079194
					</series>
					<series title="cumulative" type="l" color="0x000000" encoding="csv">300.73666545559195,0.0
403.72984671089137,0.22
506.7230279661908,0.5
609.7162092214902,0.72
712.7093904767896,0.86
815.702571732089,0.92
918.6957529873885,0.97
1021.6889342426879,0.97
1124.6821154979873,0.98
1227.6752967532866,0.99
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">538.8280320206784,0.0
538.8280320206784,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=102.99, bucket count=10
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [300.7, 1331]
Mean estimate of displayed sample: 538.8 ± 36.07 (95% CI)</comment>
				</plot>
				<plot title="Frequency Histogram" xaxis="max: x * (allDone ? 0 : 1)" yaxis="count">
					<series title="count" type="b(102.993181)" color="0x0000ff" encoding="csv">300.73666545559195,22.0
403.72984671089137,28.0
506.7230279661908,22.0
609.7162092214902,14.0
712.7093904767896,6.0
815.702571732089,5.0
918.6957529873885,0.0
1021.6889342426879,1.0
1124.6821154979873,1.0
1227.6752967532866,1.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">538.8280320206784,0.0
538.8280320206784,28.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=102.99, bucket count=10
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [300.7, 1331]
Mean estimate of displayed sample: 538.8 ± 36.07 (95% CI)</comment>
				</plot>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=10000; 100](&lt;&gt; sameCycle &amp;&amp; allDone)</formula>
			<comment>It would be nice to have the reverse query.
Within this time, how much time does it take at most to reach this state?
There should be a few edge cases where a robot takes one more cycle than the others. 
This is because of unknown interleavings that causes a single robot (seemingly a robot with only one neighbor) 
to not calculate their decision group size correctly at the first cycle where all robots agree.</comment>
			<result outcome="success" type="interval" value="≥ 0.963783 (95% CI)" timestamp="2025-05-09 10:54:48 +0200">
				<option key="--diagnostic" value="-1"/>
				<details>≥ 0.963783 (95% CI)</details>
				<plot title="Probability Density Distribution" xaxis="run duration in time" yaxis="probability density">
					<series title="density" type="b(66.299160)" color="0x0000ff" encoding="csv">274.4102094398195,9.049888436575551E-4
340.7093692808482,0.002111640635200962
407.0085291218769,0.0033182924267443686
473.3076889629057,0.0024133035830868135
539.6068488039343,0.0024133035830868135
605.9060086449631,0.0013574832654863326
672.2051684859919,0.0012066517915434068
738.5043283270206,4.5249442182877754E-4
804.8034881680493,6.033258957717034E-4
871.102648009078,3.016629478858517E-4
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">529.9967920811255,0.0
529.9967920811255,0.0033182924267443686
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=66.299, bucket count=10
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [274.4, 937.4]
Mean estimate of displayed sample: 530 ± 28.59 (95% CI)</comment>
				</plot>
				<plot title="Probability Density Confidence Intervals" xaxis="run duration in time" yaxis="probability density">
					<series title="upper limit" type="b(66.299160)" color="0xa0a0ff" encoding="csv">274.4102094398195,0.12602993458082296
340.7093692808482,0.22372798137056776
407.0085291218769,0.31391965378631786
473.3076889629057,0.24678759741086234
539.6068488039343,0.24678759741086234
605.9060086449631,0.16398225502963523
672.2051684859919,0.15155763586442098
738.5043283270206,0.08517605297428003
804.8034881680493,0.09925715671265992
871.102648009078,0.07038393247107012
					</series>
					<series title="lower limit" type="b(66.299160)" color="0x0000ff" encoding="csv">274.4102094398195,0.022334886071316375
340.7093692808482,0.07870540492696577
407.0085291218769,0.14330357674981448
473.3076889629057,0.09431028997394622
539.6068488039343,0.09431028997394622
605.9060086449631,0.04198359562839223
672.2051684859919,0.03517156251816281
738.5043283270206,0.006229971538306394
804.8034881680493,0.011004493986188203
871.102648009078,0.0024313368239425423
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">529.9967920811255,0.0
529.9967920811255,0.004734896408024331
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=66.299, bucket count=10
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [274.4, 937.4]
Mean estimate of displayed sample: 530 ± 28.59 (95% CI)</comment>
				</plot>
				<plot title="Probability Distribution" xaxis="run duration in time" yaxis="probability">
					<series title="probability" type="b(66.299160)" color="0x0000ff" encoding="csv">274.4102094398195,0.06
340.7093692808482,0.14
407.0085291218769,0.22
473.3076889629057,0.16
539.6068488039343,0.16
605.9060086449631,0.09
672.2051684859919,0.08
738.5043283270206,0.03
804.8034881680493,0.04
871.102648009078,0.02
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">529.9967920811255,0.0
529.9967920811255,0.22
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=66.299, bucket count=10
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [274.4, 937.4]
Mean estimate of displayed sample: 530 ± 28.59 (95% CI)</comment>
				</plot>
				<plot title="Probability Confidence Intervals" xaxis="run duration in time" yaxis="probability">
					<series title="upper limit" type="b(66.299160)" color="0xa0a0ff" encoding="csv">274.4102094398195,0.12602993458082296
340.7093692808482,0.22372798137056776
407.0085291218769,0.31391965378631786
473.3076889629057,0.24678759741086234
539.6068488039343,0.24678759741086234
605.9060086449631,0.16398225502963523
672.2051684859919,0.15155763586442098
738.5043283270206,0.08517605297428003
804.8034881680493,0.09925715671265992
871.102648009078,0.07038393247107012
					</series>
					<series title="lower limit" type="b(66.299160)" color="0x0000ff" encoding="csv">274.4102094398195,0.022334886071316375
340.7093692808482,0.07870540492696577
407.0085291218769,0.14330357674981448
473.3076889629057,0.09431028997394622
539.6068488039343,0.09431028997394622
605.9060086449631,0.04198359562839223
672.2051684859919,0.03517156251816281
738.5043283270206,0.006229971538306394
804.8034881680493,0.011004493986188203
871.102648009078,0.0024313368239425423
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">529.9967920811255,0.0
529.9967920811255,0.31391965378631786
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=66.299, bucket count=10
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [274.4, 937.4]
Mean estimate of displayed sample: 530 ± 28.59 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Distribution" xaxis="run duration in time" yaxis="probability">
					<series title="cumulative" type="l" color="0x000000" encoding="csv">274.4102094398195,0.0
340.7093692808482,0.06
407.0085291218769,0.2
473.3076889629057,0.42
539.6068488039343,0.58
605.9060086449631,0.74
672.2051684859919,0.83
738.5043283270206,0.91
804.8034881680493,0.94
871.102648009078,0.98
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">529.9967920811255,0.0
529.9967920811255,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=66.299, bucket count=10
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [274.4, 937.4]
Mean estimate of displayed sample: 530 ± 28.59 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Confidence Intervals" xaxis="run duration in time" yaxis="probability">
					<series title="upper limit" type="k" color="0x0000dd" encoding="csv">274.4102094398195,0.03621669264517642
340.7093692808482,0.12602993458082296
407.0085291218769,0.2918426890886281
473.3076889629057,0.5228808042760862
539.6068488039343,0.6780144606452031
605.9060086449631,0.8226055621323475
672.2051684859919,0.8977350899644717
738.5043283270206,0.9580164043716077
804.8034881680493,0.9776651139286836
871.102648009078,0.9975686631760574
					</series>
					<series title="lower limit" type="k" color="0xdd0000" encoding="csv">274.4102094398195,0.0
340.7093692808482,0.022334886071316375
407.0085291218769,0.12665555210195586
473.3076889629057,0.3219855393547969
539.6068488039343,0.47711919572391376
605.9060086449631,0.6426879368998965
672.2051684859919,0.7418245893678413
738.5043283270206,0.8360177449703647
804.8034881680493,0.873970065419177
871.102648009078,0.9296160675289299
					</series>
					<series title="cumulative" type="l" color="0x000000" encoding="csv">274.4102094398195,0.0
340.7093692808482,0.06
407.0085291218769,0.2
473.3076889629057,0.42
539.6068488039343,0.58
605.9060086449631,0.74
672.2051684859919,0.83
738.5043283270206,0.91
804.8034881680493,0.94
871.102648009078,0.98
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">529.9967920811255,0.0
529.9967920811255,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=66.299, bucket count=10
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [274.4, 937.4]
Mean estimate of displayed sample: 530 ± 28.59 (95% CI)</comment>
				</plot>
				<plot title="Frequency Histogram" xaxis="run duration in time" yaxis="count">
					<series title="count" type="b(66.299160)" color="0x0000ff" encoding="csv">274.4102094398195,6.0
340.7093692808482,14.0
407.0085291218769,22.0
473.3076889629057,16.0
539.6068488039343,16.0
605.9060086449631,9.0
672.2051684859919,8.0
738.5043283270206,3.0
804.8034881680493,4.0
871.102648009078,2.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">529.9967920811255,0.0
529.9967920811255,22.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=66.299, bucket count=10
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [274.4, 937.4]
Mean estimate of displayed sample: 530 ± 28.59 (95% CI)</comment>
				</plot>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=10000]([] allDone imply sameCycle) &gt;= 0.98</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2025-05-09 10:55:29 +0200">
				<option key="--diagnostic" value="-1"/>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=10000](&lt;&gt; allDone) &gt;= 0.98</formula>
			<comment/>
			<option key="--generate-strategy" value="-1"/>
			<option key="--search-order" value="2"/>
			<option key="--diagnostic" value="0"/>
			<result outcome="success" type="quality" timestamp="2025-05-09 11:00:42 +0200">
				<option key="--generate-strategy" value="-1"/>
				<option key="--search-order" value="2"/>
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=10000](&lt;&gt; Robot(0).Terminal) &gt;= 0.98</formula>
			<comment/>
			<result outcome="success" type="quality" timestamp="2025-05-09 11:04:55 +0200">
				<option key="--diagnostic" value="-1"/>
			</result>
		</query>
		<query>
			<formula>simulate [&lt;=11000; 100] { allDone } : 1 :  !allDone &amp;&amp; (x &gt;= 10000)</formula>
			<comment>Counterexamples, should fail</comment>
			<option key="--diagnostic" value="0"/>
			<result outcome="failure" type="interval" value="≤ 0.0362167 (95% CI)" timestamp="2025-05-09 11:08:41 +0200">
				<option key="--diagnostic" value="0"/>
				<details>≤ 0.0362167 (95% CI)</details>
			</result>
		</query>
	</queries>
</nta>
