<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>

//// ================================================
//// Constants and type definition

// Maximally connected network
/* 
const int R = 7;                       // Number of robots
const int Q = 4;                       // Number of choices
const int NN = 6;                      // Max number of neighbors

bool C[R][R] = {{false, true, true, true, true, true, true},
               {true, false, true, true, true, true, true},
               {true, true, false, true, true, true, true},
               {true, true, true, false, true, true, true},
               {true, true, true, true, false, true, true},
               {true, true, true, true, true, false, true},
               {true, true, true, true, true, true, false}};
*/

// Minimally connected network

const int R = 7;                       // Number of robots
const int Q = 4;                       // Number of choices
const int NN = 2;                      // Max number of neighbors

bool C[R][R] = {{false, true, false, false, false, false, false},
               {true, false, true, false, false, false, false},
               {false, true, false, true, false, false, false},
               {false, false, true, false, true, false, false},
               {false, false, false, true, false, true, false},
               {false, false, false, false, true, false, true},
               {false, false, false, false, false, true, false}};




typedef int[0,NN-1] neighbor;          // The set of possible neighbor indexes
typedef int[-1,NN-1] optionalNeighbor; // The set of possible neighbor indexes, -1 denoting null
typedef int[0,2] timestamp;            // Synchronization following rock-paper-scissors logic ( 0 &lt; 1 &lt; 2 &lt; 0 )
typedef int[0,Q-1] choice;             // The set of choice indexes
typedef int[-1,Q-1] optionalChoice;    // The set of choice indexes
typedef int[0,R-1] robot;              // The set of robot ids
typedef int[-1,R-1] optionalRobot;     // The set of robot ids, -1 denoting null

//// ================================================
//// Robot state

/* Most state is kept in global variables. 
However, a robot only ever accesses the state of its neighbors. 
In this we abstract away the specific communication protocal, while maintaining the requirement that robots have no global knowledge. */


/* The public decision of each robot. Is updated (along P), after publicP and ND but before any neighbor starts recalculating D */
choice decision[R];

/*The decision group of each robot - true means the robot of that ID is in the same group. Is continuously updated while in the calculateDsize state*/
bool D[R][R];

/* The public preferences of each robot - the preferences are only updated simultaneously with ND */
double publicP[R][Q];

/* The public size of the donsensus group of each robot. 
Is updated atomically, after having calculated D.
The paper calls this the consensus group, we call it the [D]ecision group 
This is to phonetically align the use of C and D for neighbors (connected robots) and consenting (same decision) respectively.*/
int[0,R] ND[R];

/* The reason why some fields are updated atomically and others continuously is because they are used for different purposes:
publicP and ND are used when updating neighboring robots preferences, and so they should represent the last coherent state.
D is used for propagating information to calculate ND, and so it updates continuously.
decision is determined right after P is updated. */

// Locking state
timestamp cycle[R];        // Used to synchronize cyclus.
timestamp level[R];        // Synchronization while calculating D.
timestamp calm[R];         // Used for determining when D has been calculated.

//// =================================================
//// Functions

// Timestamps

// Returns true if the timestamp of robot r is behind or at equal to that of robot s. False if r is in front.
bool compareTimestamps(timestamp a, timestamp b) {
    if (a == b) return true;
    if ((a + 1) % 3 == b) return true;
    return false;
}

// Populate array with random values summing to 1 (PMF)
void initP(double &amp;P[Q]){
    double rands[Q];
    double ssum = 0;
    for (i : choice) {
        double val = random(1);
        rands[i] = val;
        ssum = ssum + val;
    }
    for (i : choice) {
        P[i] = rands[i] / ssum;
    }
}

// Count the number of true values in array
int[0,R] count(bool &amp;A[R]){
    return sum (i : robot) A[i] == true;
}

// Get the index of a highest value
choice maxIndex(double &amp;P[Q]){
    choice maxI = 0;
    double max = 0;
    for (i : choice){
        if (P[i] &gt; max) {
            max = P[i];
            maxI = i;
        }
    }
    return maxI;
}

// Get next true value of boolean array A *after* index i.
// Returns -1 if there is no next value
optionalRobot getNextTrue(int i, bool &amp;A[R]){
    while (i &lt; R-1) {
        i++;
        if (A[i]) return i;
        
    }
    return -1;
}

//// ================================================
//// Meta

// Return true if all values are equal. Used for verification
bool allSameTimestamp(timestamp &amp;A[R]){
    timestamp comparison = A[0];
    return forall (i : int[1,R-1]) A[i] == comparison;
}

// Have a robot finished
bool done[R];
bool allDone = false;
bool allSameCycleAndDone = false;
bool notSameCycleAndDone = false;
bool sameCycle = false;
clock x = 0;</declaration>
	<template>
		<name>Robot</name>
		<parameter>robot id</parameter>
		<declaration>//// =====================================================
//// State


int cyclecounter = 0;

optionalRobot neighbors[NN];           // Inverted index of neighbors, index 0 to count(C)-1 contains index of true values in C. -1 for empty slots.
bool mayContinue;                      // Guard and synchronization variable - is updated with compareCycle() and compareLevels()
double P[Q];                           // Preferences as a PMF over all choices in Q.

//// =====================================================
//// Methods
// Functions that are simplified by having access to state

    //// Utility

bool isInSameCycle(robot r)      { return cycle[r] == cycle[id]; }
bool isConsenting(robot r)       { return decision[r] == decision[id]; }
bool isRobot(optionalRobot r)    { return r != -1; }
bool isCalm(robot r)             { return calm[r] &gt; 0; }
bool isLowerLevel(robot r)       { return !compareTimestamps(level[id], level[r]); }
bool isInEarlierCycle(robot r)   { return !compareTimestamps(cycle[id], cycle[r]); }
void incrementLevel()            { level[id] = (level[id] + 1) % 3; }

/**Increment cycle by one and reset lower synchronization variables*/
void incrementCycle()            { 
    cycle[id] = (cycle[id] + 1) % 3; 
    level[id] = 0;
    calm[id] = 0;
    cyclecounter++;
}


    //// Synchronization methods

/**Returns true if the all neighbors are on the same or next cycle as self.*/
/* We need both cases (same cycle or next) because a neighboring disagreeing robot may complete a full loop and enter the next cycle before this robot continues.
We need to wait for every neighbor, else updating behavior is different for robots in different sized decision groups. */
bool compareCycle() {
    optionalRobot r;

    for (n : neighbor) {
        r = neighbors[n];
        if (isRobot(r) &amp;&amp; isInEarlierCycle(r)) { return false; }
    }
    return true;

}

/**Returns true if no consenting neighbor is behind this robot in updating their D array.*/
/* This ensures that the robot does not ask a neighbor twice before that neighbor has a chance to update their values.
A neighbor can never be in an earlier cycle than this robot when compareLevels() is called.
This is because compareLevelsConsenting is only called in state `FindingDecisionGroup`.
Cycles are only incremented when entering state `AwaitingNeighbors`, and `AwaitingNeighbors` can only be exited when all neighbors are in the same or next cycle*/
bool compareLevelsConsenting() {
    optionalRobot r;

    for (n : neighbor) {
        r = neighbors[n];
        if (isRobot(r) &amp;&amp; isConsenting(r) &amp;&amp; isInSameCycle(r) &amp;&amp; isLowerLevel(r)) {  return false; }
    }
    return true;
}

/**Returns true if every neighbor has updated their preference.*/
/* This ensures that the robot does not start calculating their Decision groups based on outdated information.
A neighbor can never be in an earlier cycle than this robot when compareLevels() is called.
This is because compareLevels is only called in state `PreferencesUpdated`.
Cycles are only incremented when entering state `AwaitingNeighbors`, and `AwaitingNeighbors` can only be exited when all neighbors are in the same or next cycle*/
bool compareLevels() {
    optionalRobot r;

    for (n : neighbor) {
        r = neighbors[n];
        if (isRobot(r) &amp;&amp; isInSameCycle(r) &amp;&amp; isLowerLevel(r)) {  return false; }
    }
    return true;
}


/**Returns true if no consenting, updating, neighbor has a calmness of 0.*/
/* As this method is only colled when this robots calmness is 1, it works like a comparison, asking: are all eligible neighbors at the same or highe level of calmness?*/
bool compareCalmness() {
    optionalRobot r;

    for (n : neighbor) {
        r = neighbors[n];
        if (isRobot(r) &amp;&amp; isConsenting(r) &amp;&amp; isInSameCycle(r) &amp;&amp; (isLowerLevel(r) || !isCalm(r))) { return false; }
    }
    return true;
}

    //// Updating and calculating preferences (P)

/**Updates the preferences of this robot according to the equation given in (Liu &amp; Lee, 2020)*/
/* Uses the last coherent state of each neighbor.*/
void updateP() {
    double sumP[Q];    // The sum of all neighbor's preference value for each choice (including self)
    int sumND;         // The total size of all neighbor's decision groups (including self)
    optionalRobot r;

    // First add yourself
    for (c : choice) {
                sumP[c] = sumP[c] + ND[id] * publicP[id][c];
    }
    sumND += ND[id];

    // Then add the each neighbor
    for (n : neighbor) {
        r = neighbors[n];
        if ( isRobot(r) ) {
            for (c : choice) {
                sumP[c] = sumP[c] + ND[r] * publicP[r][c];
            }
            sumND += ND[r];
        }
    }

    // Normalize
    for (c : choice) { P[c] = sumP[c] / sumND; } 
}

    //// Calculating consensus / decision group (D)

/** Add every robot to the decision group (D) of this robot that are present in the decision group of any neighbors with the same decision as this.
The function returns false if no new robots were added. */
bool syncWithConsentingNeighbors() {
    bool stale = true;
    optionalRobot r;

    for (n : neighbor) {
        r = neighbors[n];
        if (isRobot(r) &amp;&amp; isConsenting(r)) {
            for (s : robot) {
                stale &amp;= (D[r][s] imply D[id][s]);  // Information is only new if the neighbor knows of an id that is in the group that this robot does not.
                D[id][s] = D[r][s] || D[id][s];     // Union operation
            }
        }
    }
    return stale;
}

    //// Initializations

// Resets the D array. 
void resetD() {
    for (r : robot) { D[id][r] = false; }
    D[id][id] = true;                      // A robot always agrees with itself
}

// Create inverted Index of neighbors (neighbors array)
void initNeighbors() {
    optionalRobot nextNeighbor;
    nextNeighbor = getNextTrue(-1, C[id]);                    // Find first neighboring robot

    for (n : neighbor) {
        if (isRobot(nextNeighbor)) {
            neighbors[n] = nextNeighbor;                  // Save neighbor in neighbors
            nextNeighbor = getNextTrue(nextNeighbor, C[id]);  // Find next neighboring robot
        } else {
            neighbors[n] = -1;                            // If there are no more neighbors
        }
    }
}

// Initialize a robot with random preferences.
void initialize() {
    initP(P);
    decision[id] = maxIndex(P);
    initNeighbors();
    level[id] = 0;
    cycle[id] = 0;
    resetD();
    level[id] = 1;
    mayContinue = false;
    // Meta values
    cyclecounter = 0;
    allDone = false;
    allSameCycleAndDone = false;
    done[id] = false;
    x = 0;
    sameCycle = false;
}

</declaration>
		<location id="id0" x="-178" y="-136">
			<name x="-161" y="-153">Initial</name>
			<committed/>
		</location>
		<location id="id1" x="-178" y="-212">
			<name x="-144" y="-221">PreferencesUpdated</name>
			<label kind="exponentialrate" x="-178" y="-221">1</label>
		</location>
		<location id="id2" x="187" y="-85">
			<name x="212" y="-119">FindingDecisionGroup</name>
			<label kind="exponentialrate" x="187" y="-93">1</label>
		</location>
		<location id="id3" x="187" y="-331">
			<name x="204" y="-357">AwaitingNeighbors</name>
			<label kind="exponentialrate" x="187" y="-340">1</label>
		</location>
		<location id="id4" x="552" y="-17">
			<name x="569" y="-25">CheckCalmness</name>
			<label kind="exponentialrate" x="552" y="-25">1</label>
		</location>
		<location id="id5" x="756" y="-331">
			<name x="746" y="-365">Terminal</name>
			<label kind="exponentialrate" x="748" y="-340">1</label>
		</location>
		<init ref="id0"/>
		<transition id="id6">
			<source ref="id1"/>
			<target ref="id1"/>
			<label kind="guard" x="-340" y="-238">!mayContinue</label>
			<label kind="assignment" x="-476" y="-221">mayContinue = compareLevels()</label>
			<nail x="-238" y="-238"/>
			<nail x="-238" y="-187"/>
		</transition>
		<transition id="id7">
			<source ref="id3"/>
			<target ref="id5"/>
			<label kind="guard" x="408" y="-348">ND[id] == R</label>
			<label kind="assignment" x="408" y="-331">done[id] = true,
allDone = count(done) == R ? 1 : 0,
sameCycle = allSameTimestamp(cycle),
allSameCycleAndDone = allSameTimestamp(cycle) &amp;&amp; allDone,
notSameCycleAndDone = !allSameTimestamp(cycle) &amp;&amp; allDone</label>
			<label kind="comments" x="408" y="-221">These updates are only for verification (SMC)</label>
		</transition>
		<transition id="id8">
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="238" y="76">calm[id] == 1</label>
			<label kind="assignment" x="153" y="93">calm[id] = compareCalmness() ? 2 : 1</label>
			<nail x="552" y="93"/>
			<nail x="136" y="93"/>
			<nail x="136" y="-85"/>
		</transition>
		<transition id="id9">
			<source ref="id4"/>
			<target ref="id2"/>
			<label kind="guard" x="238" y="25">calm[id] == 0</label>
			<nail x="552" y="42"/>
			<nail x="136" y="42"/>
			<nail x="136" y="-85"/>
		</transition>
		<transition id="id10">
			<source ref="id3"/>
			<target ref="id3"/>
			<label kind="guard" x="102" y="-416">!mayContinue &amp;&amp; ND[id] != R</label>
			<label kind="assignment" x="110" y="-399">mayContinue = compareCycle()</label>
			<nail x="204" y="-374"/>
			<nail x="170" y="-374"/>
		</transition>
		<transition id="id11">
			<source ref="id3"/>
			<target ref="id1"/>
			<label kind="guard" x="-246" y="-365">mayContinue &amp;&amp; ND[id] != R</label>
			<label kind="assignment" x="-246" y="-348">updateP(),
decision[id] = maxIndex(P),
resetD(),
level[id] = 1,
mayContinue = false</label>
		</transition>
		<transition id="id12">
			<source ref="id2"/>
			<target ref="id3"/>
			<label kind="guard" x="195" y="-289">calm[id] == 2</label>
			<label kind="assignment" x="195" y="-272">ND[id] = count(D[id]),
publicP[id] = P,
mayContinue = false,
incrementCycle()</label>
			<nail x="187" y="-102"/>
		</transition>
		<transition id="id13">
			<source ref="id2"/>
			<target ref="id2"/>
			<label kind="guard" x="195" y="-59">!mayContinue &amp;&amp; calm[id] &lt; 2</label>
			<label kind="assignment" x="195" y="-42">mayContinue = compareLevelsConsenting()</label>
			<nail x="187" y="-17"/>
			<nail x="136" y="-17"/>
			<nail x="136" y="-85"/>
		</transition>
		<transition id="id14">
			<source ref="id2"/>
			<target ref="id4"/>
			<label kind="guard" x="212" y="-102">mayContinue &amp;&amp; calm[id] &lt; 2</label>
			<label kind="assignment" x="561" y="-93">calm[id] = syncWithConsentingNeighbors() ? 1 : 0,
incrementLevel(),
mayContinue = compareLevelsConsenting()</label>
			<nail x="552" y="-85"/>
		</transition>
		<transition id="id15">
			<source ref="id1"/>
			<target ref="id2"/>
			<label kind="guard" x="8" y="-178">mayContinue</label>
			<label kind="assignment" x="8" y="-161">mayContinue = false</label>
		</transition>
		<transition id="id16">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="assignment" x="-170" y="-170">initialize()</label>
		</transition>
	</template>
	<system>system Robot;
</system>
	<queries>
		<option key="--diagnostic" value="1"/>
		<query>
			<formula>E[&lt;=10000; 100](max: Robot(0).cyclecounter)</formula>
			<comment>How many cycles in total does robot 0 go through before consensus is reached.

Results:
For 7 robots with random preferences in a fully connected graphs. [&lt;=1000;5000] ≈ 2 (as expected)</comment>
			<option key="--exploration" value="0"/>
			<option key="--diagnostic" value="1"/>
			<result outcome="success" type="quantity" value="10.01 ± 1.48284 (95% CI)" timestamp="2025-04-29 22:54:24 +0200">
				<option key="--exploration" value="0"/>
				<option key="--diagnostic" value="1"/>
				<details>10.01 ± 1.48284 (95% CI)</details>
				<plot title="Probability Density Distribution" xaxis="max: Robot[0].cyclecounter" yaxis="probability density">
					<series title="density" type="b(3.000000)" color="0x0000ff" encoding="csv">2.0,0.10333333333333333
5.0,0.056666666666666664
8.0,0.06
11.0,0.023333333333333334
14.0,0.02666666666666667
17.0,0.03
20.0,0.006666666666666667
23.0,0.006666666666666667
26.0,0.006666666666666667
29.0,0.006666666666666667
32.0,0.006666666666666667
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">10.01,0.0
10.01,0.10333333333333333
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=3, bucket count=11
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [2, 34]
Mean estimate of displayed sample: 10.01 ± 1.483 (95% CI)</comment>
				</plot>
				<plot title="Probability Distribution" xaxis="max: Robot[0].cyclecounter" yaxis="probability">
					<series title="probability" type="b(3.000000)" color="0x0000ff" encoding="csv">2.0,0.31
5.0,0.17
8.0,0.18
11.0,0.07
14.0,0.08
17.0,0.09
20.0,0.02
23.0,0.02
26.0,0.02
29.0,0.02
32.0,0.02
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">10.01,0.0
10.01,0.31
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=3, bucket count=11
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [2, 34]
Mean estimate of displayed sample: 10.01 ± 1.483 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Distribution" xaxis="max: Robot[0].cyclecounter" yaxis="probability">
					<series title="cumulative" type="l" color="0x000000" encoding="csv">2.0,0.0
5.0,0.31
8.0,0.48
11.0,0.66
14.0,0.73
17.0,0.81
20.0,0.9
23.0,0.92
26.0,0.94
29.0,0.96
32.0,0.98
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">10.01,0.0
10.01,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=3, bucket count=11
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [2, 34]
Mean estimate of displayed sample: 10.01 ± 1.483 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Confidence Intervals" xaxis="max: Robot[0].cyclecounter" yaxis="probability">
					<series title="upper limit" type="k" color="0x0000dd" encoding="csv">2.0,0.03621669264517642
5.0,0.4103145541601993
8.0,0.5822102345936934
11.0,0.7517764984551558
14.0,0.8139335777092593
17.0,0.8815568038674564
20.0,0.9509953107785141
23.0,0.9648284374818372
26.0,0.9776651139286836
29.0,0.9889955060138118
32.0,0.9975686631760574
					</series>
					<series title="lower limit" type="k" color="0xdd0000" encoding="csv">2.0,0.0
5.0,0.22128879213067107
8.0,0.3790054801779586
11.0,0.5584667322490411
14.0,0.6319837270910251
17.0,0.7193020420263875
20.0,0.8237774022599773
23.0,0.848442364135579
26.0,0.873970065419177
29.0,0.9007428432873401
32.0,0.9296160675289299
					</series>
					<series title="cumulative" type="l" color="0x000000" encoding="csv">2.0,0.0
5.0,0.31
8.0,0.48
11.0,0.66
14.0,0.73
17.0,0.81
20.0,0.9
23.0,0.92
26.0,0.94
29.0,0.96
32.0,0.98
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">10.01,0.0
10.01,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=3, bucket count=11
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [2, 34]
Mean estimate of displayed sample: 10.01 ± 1.483 (95% CI)</comment>
				</plot>
				<plot title="Frequency Histogram" xaxis="max: Robot[0].cyclecounter" yaxis="count">
					<series title="count" type="b(3.000000)" color="0x0000ff" encoding="csv">2.0,31.0
5.0,17.0
8.0,18.0
11.0,7.0
14.0,8.0
17.0,9.0
20.0,2.0
23.0,2.0
26.0,2.0
29.0,2.0
32.0,2.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">10.01,0.0
10.01,31.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=3, bucket count=11
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [2, 34]
Mean estimate of displayed sample: 10.01 ± 1.483 (95% CI)</comment>
				</plot>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=10000]([] (Robot(0).Terminal &amp;&amp; Robot(1).Terminal &amp;&amp; Robot(2).Terminal &amp;&amp; Robot(3).Terminal &amp;&amp; Robot(4).Terminal &amp;&amp; Robot(5).Terminal &amp;&amp; Robot(6).Terminal ) imply allDone) &gt;= 0.95</formula>
			<comment/>
		</query>
		<query>
			<formula>Pr[&lt;=10000]([] (Robot(0).Terminal &amp;&amp; Robot(1).Terminal &amp;&amp; Robot(2).Terminal &amp;&amp; Robot(3).Terminal &amp;&amp; Robot(4).Terminal &amp;&amp; Robot(5).Terminal &amp;&amp; Robot(6).Terminal) ) &gt;= 0.95</formula>
			<comment/>
		</query>
		<query>
			<formula>Pr[&lt;=10000](&lt;&gt; allSameCycleAndDone)</formula>
			<comment>Forstår slet ikke hvordan den kommer frem til de tal, den gør. Jeg har endnu ikke set et trace, der understøtter det.</comment>
			<option key="--exploration" value="0"/>
			<option key="--diagnostic" value="1"/>
		</query>
		<query>
			<formula>Pr[&lt;=10000]([] !allDone) &lt;= 0.06</formula>
			<comment/>
			<option key="--diagnostic" value="0"/>
			<result outcome="failure" type="quality" timestamp="2025-04-29 23:07:13 +0200">
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
		<query>
			<formula>Pr[x&lt;=1000](&lt;&gt; Robot(0).Terminal)</formula>
			<comment/>
			<result outcome="success" type="quantity" value="0.879887 ± 0.0445082 (95% CI)" timestamp="2025-04-29 22:33:00 +0200">
				<option key="--diagnostic" value="1"/>
				<details>0.879887 ± 0.0445082 (95% CI)</details>
				<plot title="Probability Density Distribution" xaxis="x" yaxis="probability density">
					<series title="density" type="b(52.808869)" color="0x0000ff" encoding="csv">25.37188687034933,0.0033876711740798734
78.18075567013719,0.0033876711740798734
130.98962446992505,0.0026927642665763095
183.79849326971294,0.0019109939956348002
236.6073620695008,0.0017372672687589095
289.41623086928865,0.0010423603612553457
342.22509966907654,5.211801806276729E-4
395.0339684688644,3.4745345375178187E-4
447.84283726865226,3.4745345375178187E-4
500.65170606844015,6.080435440656182E-4
553.4605748682279,4.3431681718972737E-4
606.2694436680158,8.686336343794547E-5
659.0783124678037,8.686336343794547E-5
711.8871812675916,1.7372672687589094E-4
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">205.72996107654302,0.0
205.72996107654302,0.0033876711740798734
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=52.809, bucket count=14
Runs: 218 in total, 193 (88.532%) displayed, 25 (11.468%) remaining
Span of displayed sample: [25.37, 764.7]
Mean estimate of displayed sample: 205.7 ± 22.04 (95% CI)</comment>
				</plot>
				<plot title="Probability Density Confidence Intervals" xaxis="x" yaxis="probability density">
					<series title="upper limit" type="b(52.808869)" color="0xa0a0ff" encoding="csv">25.37188687034933,0.23634379595798882
78.18075567013719,0.23634379595798882
130.98962446992505,0.19573238100749615
183.79849326971294,0.14879916158580853
236.6073620695008,0.1381321782147224
289.41623086928865,0.09417928887409727
342.22509966907654,0.058940263189240914
395.0339684688644,0.04631086370539687
447.84283726865226,0.04631086370539687
500.65170606844015,0.06503722725477581
553.4605748682279,0.05270992905284456
606.2694436680158,0.025291614605808335
659.0783124678037,0.025291614605808335
711.8871812675916,0.03274600285357662
					</series>
					<series title="lower limit" type="b(52.808869)" color="0x0000ff" encoding="csv">25.37188687034933,0.13041587299291493
78.18075567013719,0.13041587299291493
130.98962446992505,0.09870811342475233
183.79849326971294,0.06433192064219995
236.6073620695008,0.056942387734209766
289.41623086928865,0.028763100521183103
342.22509966907654,0.010166001863889242
395.0339684688644,0.005021452104094233
447.84283726865226,0.005021452104094233
500.65170606844015,0.013005514206206568
553.4605748682279,0.00748816830913171
606.2694436680158,1.1612999026347479E-4
659.0783124678037,1.1612999026347479E-4
711.8871812675916,0.0011129892260285693
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">205.72996107654302,0.0
205.72996107654302,0.004475456515723325
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=52.809, bucket count=14
Runs: 218 in total, 193 (88.532%) displayed, 25 (11.468%) remaining
Span of displayed sample: [25.37, 764.7]
Mean estimate of displayed sample: 205.7 ± 22.04 (95% CI)</comment>
				</plot>
				<plot title="Probability Distribution" xaxis="x" yaxis="probability">
					<series title="probability" type="b(52.808869)" color="0x0000ff" encoding="csv">25.37188687034933,0.17889908256880735
78.18075567013719,0.17889908256880735
130.98962446992505,0.14220183486238533
183.79849326971294,0.10091743119266056
236.6073620695008,0.09174311926605505
289.41623086928865,0.05504587155963303
342.22509966907654,0.027522935779816515
395.0339684688644,0.01834862385321101
447.84283726865226,0.01834862385321101
500.65170606844015,0.03211009174311927
553.4605748682279,0.022935779816513763
606.2694436680158,0.0045871559633027525
659.0783124678037,0.0045871559633027525
711.8871812675916,0.009174311926605505
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">205.72996107654302,0.0
205.72996107654302,0.17889908256880735
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=52.809, bucket count=14
Runs: 218 in total, 193 (88.532%) displayed, 25 (11.468%) remaining
Span of displayed sample: [25.37, 764.7]
Mean estimate of displayed sample: 205.7 ± 22.04 (95% CI)</comment>
				</plot>
				<plot title="Probability Confidence Intervals" xaxis="x" yaxis="probability">
					<series title="upper limit" type="b(52.808869)" color="0xa0a0ff" encoding="csv">25.37188687034933,0.23634379595798882
78.18075567013719,0.23634379595798882
130.98962446992505,0.19573238100749615
183.79849326971294,0.14879916158580853
236.6073620695008,0.1381321782147224
289.41623086928865,0.09417928887409727
342.22509966907654,0.058940263189240914
395.0339684688644,0.04631086370539687
447.84283726865226,0.04631086370539687
500.65170606844015,0.06503722725477581
553.4605748682279,0.05270992905284456
606.2694436680158,0.025291614605808335
659.0783124678037,0.025291614605808335
711.8871812675916,0.03274600285357662
					</series>
					<series title="lower limit" type="b(52.808869)" color="0x0000ff" encoding="csv">25.37188687034933,0.13041587299291493
78.18075567013719,0.13041587299291493
130.98962446992505,0.09870811342475233
183.79849326971294,0.06433192064219995
236.6073620695008,0.056942387734209766
289.41623086928865,0.028763100521183103
342.22509966907654,0.010166001863889242
395.0339684688644,0.005021452104094233
447.84283726865226,0.005021452104094233
500.65170606844015,0.013005514206206568
553.4605748682279,0.00748816830913171
606.2694436680158,1.1612999026347479E-4
659.0783124678037,1.1612999026347479E-4
711.8871812675916,0.0011129892260285693
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">205.72996107654302,0.0
205.72996107654302,0.23634379595798882
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=52.809, bucket count=14
Runs: 218 in total, 193 (88.532%) displayed, 25 (11.468%) remaining
Span of displayed sample: [25.37, 764.7]
Mean estimate of displayed sample: 205.7 ± 22.04 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Distribution" xaxis="x" yaxis="probability">
					<series title="cumulative" type="l" color="0x000000" encoding="csv">25.37188687034933,0.0
78.18075567013719,0.17889908256880735
130.98962446992505,0.3577981651376147
183.79849326971294,0.5
236.6073620695008,0.6009174311926605
289.41623086928865,0.6926605504587156
342.22509966907654,0.7477064220183486
395.0339684688644,0.7752293577981652
447.84283726865226,0.7935779816513762
500.65170606844015,0.8119266055045872
553.4605748682279,0.8440366972477065
606.2694436680158,0.8669724770642202
659.0783124678037,0.8715596330275229
711.8871812675916,0.8761467889908257
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">205.72996107654302,0.0
205.72996107654302,0.8853211009174312
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=52.809, bucket count=14
Runs: 218 in total, 193 (88.532%) displayed, 25 (11.468%) remaining
Span of displayed sample: [25.37, 764.7]
Mean estimate of displayed sample: 205.7 ± 22.04 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Confidence Intervals" xaxis="x" yaxis="probability">
					<series title="upper limit" type="k" color="0x0000dd" encoding="csv">25.37188687034933,0.01677910152321745
78.18075567013719,0.23634379595798882
130.98962446992505,0.4253209874272492
183.79849326971294,0.5682689095753181
236.6073620695008,0.666444120634309
289.41623086928865,0.753199873140304
342.22509966907654,0.803926176467596
395.0339684688644,0.8288451489049532
447.84283726865226,0.8452690659335153
500.65170606844015,0.8615249260813124
553.4605748682279,0.8895086131933864
606.2694436680158,0.9090665881798864
659.0783124678037,0.9129276116558477
711.8871812675916,0.9167700138789916
					</series>
					<series title="lower limit" type="k" color="0xdd0000" encoding="csv">25.37188687034933,0.0
78.18075567013719,0.13041587299291493
130.98962446992505,0.2942016458666244
183.79849326971294,0.431731090424682
236.6073620695008,0.5326068913381921
289.41623086928865,0.6267927481797518
342.22509966907654,0.6846166440622304
395.0339684688644,0.7139655954062641
447.84283726865226,0.7337165291151365
500.65170606844015,0.7536316597909417
553.4605748682279,0.7889346572607211
606.2694436680158,0.8145674772730274
659.0783124678037,0.8197427053808561
711.8871812675916,0.824935788550547
					</series>
					<series title="cumulative" type="l" color="0x000000" encoding="csv">25.37188687034933,0.0
78.18075567013719,0.17889908256880735
130.98962446992505,0.3577981651376147
183.79849326971294,0.5
236.6073620695008,0.6009174311926605
289.41623086928865,0.6926605504587156
342.22509966907654,0.7477064220183486
395.0339684688644,0.7752293577981652
447.84283726865226,0.7935779816513762
500.65170606844015,0.8119266055045872
553.4605748682279,0.8440366972477065
606.2694436680158,0.8669724770642202
659.0783124678037,0.8715596330275229
711.8871812675916,0.8761467889908257
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">205.72996107654302,0.0
205.72996107654302,0.8853211009174312
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=52.809, bucket count=14
Runs: 218 in total, 193 (88.532%) displayed, 25 (11.468%) remaining
Span of displayed sample: [25.37, 764.7]
Mean estimate of displayed sample: 205.7 ± 22.04 (95% CI)</comment>
				</plot>
				<plot title="Frequency Histogram" xaxis="x" yaxis="count">
					<series title="count" type="b(52.808869)" color="0x0000ff" encoding="csv">25.37188687034933,39.0
78.18075567013719,39.0
130.98962446992505,31.0
183.79849326971294,22.0
236.6073620695008,20.0
289.41623086928865,12.0
342.22509966907654,6.0
395.0339684688644,4.0
447.84283726865226,4.0
500.65170606844015,7.0
553.4605748682279,5.0
606.2694436680158,1.0
659.0783124678037,1.0
711.8871812675916,2.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">205.72996107654302,0.0
205.72996107654302,39.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=52.809, bucket count=14
Runs: 218 in total, 193 (88.532%) displayed, 25 (11.468%) remaining
Span of displayed sample: [25.37, 764.7]
Mean estimate of displayed sample: 205.7 ± 22.04 (95% CI)</comment>
				</plot>
			</result>
		</query>
		<query>
			<formula>Pr[x&lt;=1000]([] allDone imply sameCycle) &gt;= 0.95</formula>
			<comment/>
			<option key="--exploration" value="0"/>
			<option key="--diagnostic" value="0"/>
			<result outcome="success" type="quality" timestamp="2025-04-29 22:49:21 +0200">
				<option key="--exploration" value="0"/>
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
		<query>
			<formula>simulate [&lt;=1000; 100] { decision } : 1 : x &gt;= 1000 &amp;&amp; !allDone</formula>
			<comment/>
			<option key="--exploration" value="0"/>
			<option key="--search-order" value="0"/>
			<option key="--diagnostic" value="1"/>
			<result outcome="success" type="quantity" value="0.406095 ± 0.399785 (95% CI)" timestamp="2025-04-29 22:38:34 +0200">
				<option key="--exploration" value="0"/>
				<option key="--search-order" value="0"/>
				<option key="--diagnostic" value="1"/>
				<details>0.406095 ± 0.399785 (95% CI)</details>
				<plot title="Simulations (1)" xaxis="time" yaxis="value">
					<series title="decision[0]" type="l" color="0xff0000" encoding="csv">0.0,0.0
0.0,1.0
4.334799044213982,1.0
4.334799044213982,0.0
50.81819741481356,0.0
50.81819741481356,1.0
1000.0,1.0
					</series>
					<series title="decision[1]" type="l" color="0xffdb00" encoding="csv">0.0,0.0
35.65424993407165,0.0
35.65424993407165,1.0
1000.0,1.0
					</series>
					<series title="decision[2]" type="l" color="0x49ff00" encoding="csv">0.0,0.0
0.0,2.0
13.086496336650162,2.0
13.086496336650162,1.0
1000.0,1.0
					</series>
					<series title="decision[3]" type="l" color="0x00ff92" encoding="csv">0.0,0.0
0.0,1.0
1000.0,1.0
					</series>
					<series title="decision[4]" type="l" color="0x0092ff" encoding="csv">0.0,0.0
0.0,1.0
1000.0,1.0
					</series>
					<series title="decision[5]" type="l" color="0x4900ff" encoding="csv">0.0,0.0
0.0,1.0
1000.0,1.0
					</series>
					<series title="decision[6]" type="l" color="0xff00db" encoding="csv">0.0,0.0
0.0,2.0
14.289781143479173,2.0
14.289781143479173,1.0
1000.0,1.0
					</series>
					<comment/>
				</plot>
			</result>
		</query>
		<query>
			<formula>E&lt;&gt; allDone</formula>
			<comment/>
			<option key="--exploration" value="1"/>
			<option key="--alpha" value="0.01"/>
			<option key="--beta" value="0.01"/>
			<option key="--epsilon" value="0.01"/>
			<option key="--diagnostic" value="1"/>
		</query>
	</queries>
</nta>
