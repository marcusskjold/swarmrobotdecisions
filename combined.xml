<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>

//// ================================================
//// Constants and type definition

// Maximally connected network
/* 
const int R = 7;                       // Number of robots
const int Q = 4;                       // Number of choices
const int NN = 6;                      // Max number of neighbors

bool C[R][R] = {{false, true, true, true, true, true, true},
               {true, false, true, true, true, true, true},
               {true, true, false, true, true, true, true},
               {true, true, true, false, true, true, true},
               {true, true, true, true, false, true, true},
               {true, true, true, true, true, false, true},
               {true, true, true, true, true, true, false}};
*/

// Minimally connected network of 7
/*
const int R = 7;                       // Number of robots
const int Q = 4;                       // Number of choices
const int NN = 2;                      // Max number of neighbors

bool C[R][R] = {{false, true, false, false, false, false, false},
               {true, false, true, false, false, false, false},
               {false, true, false, true, false, false, false},
               {false, false, true, false, true, false, false},
               {false, false, false, true, false, true, false},
               {false, false, false, false, true, false, true},
               {false, false, false, false, false, true, false}};
*/

// Minimally connected network of 10

const int R = 10;                       // Number of robots
const int Q = 4;                       // Number of choices
const int NN = 2;                      // Max number of neighbors

bool C[R][R] = {{false, true, false, false, false, false, false, false, false, false},
                {true, false, true, false, false, false, false, false, false, false},
                {false, true, false, true, false, false, false, false, false, false},
                {false, false, true, false, true, false, false, false, false, false},
                {false, false, false, true, false, true, false, false, false, false},
                {false, false, false, false, true, false, true, false, false, false},
                {false, false, false, false, false, true, false, true, false, false},
                {false, false, false, false, false, false, true, false, true, false},
                {false, false, false, false, false, false, false, true, false, true},
                {false, false, false, false, false, false, false, false, true, false}};




typedef int[0,NN-1] neighbor;          // The set of possible neighbor indexes
typedef int[-1,NN-1] optionalNeighbor; // The set of possible neighbor indexes, -1 denoting null
typedef int[0,2] timestamp;            // Synchronization following rock-paper-scissors logic ( 0 &lt; 1 &lt; 2 &lt; 0 )
typedef int[0,Q-1] choice;             // The set of choice indexes
typedef int[-1,Q-1] optionalChoice;    // The set of choice indexes
typedef int[0,R-1] robot;              // The set of robot ids
typedef int[-1,R-1] optionalRobot;     // The set of robot ids, -1 denoting null
typedef int[0,3] calmness;

//// ================================================
//// Robot state

/* Most state is kept in global variables. 
However, a robot only ever accesses the state of its neighbors. 
In this we abstract away the specific communication protocal, while maintaining the requirement that robots have no global knowledge. */


/* The public decision of each robot. Is updated (along P), after publicP and ND but before any neighbor starts recalculating D */
choice decision[R];

/*The decision group of each robot - true means the robot of that ID is in the same group. Is continuously updated while in the calculateDsize state*/
bool D[R][R];

/* The public preferences of each robot - the preferences are only updated simultaneously with ND */
double publicP[R][Q];

/* The public size of the donsensus group of each robot. 
Is updated atomically, after having calculated D.
The paper calls this the consensus group, we call it the [D]ecision group 
This is to phonetically align the use of C and D for neighbors (connected robots) and consenting (same decision) respectively.*/
int[0,R] ND[R];

/* The reason why some fields are updated atomically and others continuously is because they are used for different purposes:
publicP and ND are used when updating neighboring robots preferences, and so they should represent the last coherent state.
D is used for propagating information to calculate ND, and so it updates continuously.
decision is determined right after P is updated. */

// Locking state
timestamp cycle[R];        // Used to synchronize cyclus.
timestamp level[R];        // Synchronization while calculating D.
calmness calm[R];         // Used for determining when D has been calculated.

//// =================================================
//// Functions

// Timestamps

// Returns true if the timestamp of robot r is behind or at equal to that of robot s. False if r is in front.
bool compareTimestamps(timestamp a, timestamp b) {
    if (a == b) return true;
    if ((a + 1) % 3 == b) return true;
    return false;
}

// Populate array with random values summing to 1 (PMF)
void initP(double &amp;P[Q]){
    double rands[Q];
    double ssum = 0;
    for (i : choice) {
        double val = random(1);
        rands[i] = val;
        ssum = ssum + val;
    }
    for (i : choice) {
        P[i] = rands[i] / ssum;
    }
}

// Count the number of true values in array
int[0,R] count(bool &amp;A[R]){
    return sum (i : robot) A[i] == true;
}

// Get the index of a highest value
choice maxIndex(double &amp;P[Q]){
    choice maxI = 0;
    double max = 0;
    for (i : choice){
        if (P[i] &gt; max) {
            max = P[i];
            maxI = i;
        }
    }
    return maxI;
}

// Get next true value of boolean array A *after* index i.
// Returns -1 if there is no next value
optionalRobot getNextTrue(int i, bool &amp;A[R]){
    while (i &lt; R-1) {
        i++;
        if (A[i]) return i;
        
    }
    return -1;
}

//// ================================================
//// Meta

// Return true if all values are equal. Used for verification
bool allSameTimestamp(timestamp &amp;A[R]){
    timestamp comparison = A[0];
    return forall (i : int[1,R-1]) A[i] == comparison;
}

// Have a robot finished
bool done[R];
bool allDone = false;
bool sameCycle = false;
clock x = 0;
int cyclecounter[R];</declaration>
	<template>
		<name>Robot</name>
		<parameter>robot id</parameter>
		<declaration>//// =====================================================
//// State

optionalRobot neighbors[NN];           // Inverted index of neighbors, index 0 to count(C)-1 contains index of true values in C. -1 for empty slots.
bool mayContinue;                      // Guard and synchronization variable - is updated with compareCycle() and compareLevels()
double P[Q];                           // Preferences as a PMF over all choices in Q.
bool wasUpdated;

//// =====================================================
//// Methods
// Functions that are simplified by having access to state

    //// Utility

bool isInSameCycle(robot r)      { return cycle[r] == cycle[id]; }
bool isConsenting(robot r)       { return decision[r] == decision[id]; }
bool isRobot(optionalRobot r)    { return r != -1; }
bool isCalm(robot r)             { return calm[r] &gt; 1; }
bool isLowerLevel(robot r)       { return !compareTimestamps(level[id], level[r]); }
bool isInEarlierCycle(robot r)   { return !compareTimestamps(cycle[id], cycle[r]); }
bool isDone(robot r)             { return done[r]; }
void incrementLevel()            { level[id] = (level[id] + 1) % 3; }

/**Increment cycle by one and reset lower synchronization variables*/
void incrementCycle()            { 
    cycle[id] = (cycle[id] + 1) % 3; 
    level[id] = 0;
    calm[id] = 0;
    cyclecounter[id] = cyclecounter[id] + 1;
}


    //// Synchronization methods

/**Returns true if the all neighbors are on the same or next cycle as self.*/
/* We need both cases (same cycle or next) because a neighboring disagreeing robot may complete a full loop and enter the next cycle before this robot continues.
We need to wait for every neighbor, else updating behavior is different for robots in different sized decision groups. */
bool compareCycle() {
    optionalRobot r;

    for (n : neighbor) {
        r = neighbors[n];
        if (isRobot(r) &amp;&amp; isInEarlierCycle(r)) { return false; }
    }
    return true;

}

/**Returns true if no consenting neighbor is behind this robot in updating their D array.*/
/* This ensures that the robot does not ask a neighbor twice before that neighbor has a chance to update their values.
A neighbor can never be in an earlier cycle than this robot when compareLevels() is called.
This is because compareLevelsConsenting is only called in state `FindingDecisionGroup`.
Cycles are only incremented when entering state `AwaitingNeighbors`, and `AwaitingNeighbors` can only be exited when all neighbors are in the same or next cycle*/
bool compareLevelsConsenting() {
    optionalRobot r;

    for (n : neighbor) {
        r = neighbors[n];
        if (isRobot(r) &amp;&amp; isConsenting(r) &amp;&amp; isInSameCycle(r) &amp;&amp; isLowerLevel(r) &amp;&amp; !isDone(r)) {  return false; }
    }
    return true;
}

/**Returns true if every neighbor has updated their preference.*/
/* This ensures that the robot does not start calculating their Decision groups based on outdated information.
A neighbor can never be in an earlier cycle than this robot when compareLevels() is called.
This is because compareLevels is only called in state `PreferencesUpdated`.
Cycles are only incremented when entering state `AwaitingNeighbors`, and `AwaitingNeighbors` can only be exited when all neighbors are in the same or next cycle*/
bool compareLevels() {
    optionalRobot r;

    for (n : neighbor) {
        r = neighbors[n];
        if (isRobot(r) &amp;&amp; isInSameCycle(r) &amp;&amp; isLowerLevel(r) &amp;&amp; !isDone(r)) {  return false; }
    }
    return true;
}


/**Returns true if no consenting, updating, neighbor has a calmness of 0.*/
/* As this method is only colled when this robots calmness is 1, it works like a comparison, asking: are all eligible neighbors at the same or highe level of calmness?*/
/* TODO : UPDATE TEXT */
bool compareCalmness() {
    optionalRobot r;

    for (n : neighbor) {
        r = neighbors[n];
        if (isRobot(r) &amp;&amp; isConsenting(r) &amp;&amp; isInSameCycle(r) &amp;&amp; !isDone(r) &amp;&amp; (isLowerLevel(r) || !isCalm(r))) { return false; }
    }
    return true;
}

    //// Updating and calculating preferences (P)

/**Updates the preferences of this robot according to the equation given in (Liu &amp; Lee, 2020)*/
/* Uses the last coherent state of each neighbor.*/
void updateP() {
    double sumP[Q];    // The sum of all neighbor's preference value for each choice (including self)
    int sumND;         // The total size of all neighbor's decision groups (including self)
    optionalRobot r;

    // First add yourself
    for (c : choice) {
                sumP[c] = sumP[c] + ND[id] * publicP[id][c];
    }
    sumND += ND[id];

    // Then add the each neighbor
    for (n : neighbor) {
        r = neighbors[n];
        if ( isRobot(r) ) {
            for (c : choice) {
                sumP[c] = sumP[c] + ND[r] * publicP[r][c];
            }
            sumND += ND[r];
        }
    }

    // Normalize
    for (c : choice) { P[c] = sumP[c] / sumND; } 
}

    //// Calculating consensus / decision group (D)

/** Add every robot to the decision group (D) of this robot that are present in the decision group of any neighbors with the same decision as this.
The function returns true if no new robots were added. */
bool syncWithConsentingNeighbors() {
    bool stale = true;
    optionalRobot r;

    for (n : neighbor) {
        r = neighbors[n];
        if (isRobot(r) &amp;&amp; isConsenting(r)) {
            for (s : robot) {
                stale &amp;= (D[r][s] imply D[id][s]);  // Information is only new if the neighbor knows of an id that is in the group that this robot does not.
                D[id][s] = D[r][s] || D[id][s];     // Union operation
            }
        }
    }
    return stale;
}

void evaluateCalmness() {
    if (wasUpdated) { calm[id] = 0; }
    else if (calm[id] &lt; 2) { calm[id] = calm[id] + 1; }
    else if (compareCalmness()) { calm[id] = 3; }
    else { calm[id] = 2; }
}

    //// Initializations

// Resets the D array. 
void resetD() {
    for (r : robot) { D[id][r] = false; }
    D[id][id] = true;                      // A robot always agrees with itself
}

// Create inverted Index of neighbors (neighbors array)
void initNeighbors() {
    optionalRobot nextNeighbor;
    nextNeighbor = getNextTrue(-1, C[id]);                    // Find first neighboring robot

    for (n : neighbor) {
        if (isRobot(nextNeighbor)) {
            neighbors[n] = nextNeighbor;                  // Save neighbor in neighbors
            nextNeighbor = getNextTrue(nextNeighbor, C[id]);  // Find next neighboring robot
        } else {
            neighbors[n] = -1;                            // If there are no more neighbors
        }
    }
}

// Initialize a robot with random preferences.
void initialize() {
    initP(P);
    decision[id] = maxIndex(P);
    initNeighbors();
    level[id] = 0;
    cycle[id] = 0;
    resetD();
    level[id] = 1;
    mayContinue = false;
    // Meta values
    cyclecounter[id] = 0;
    allDone = false;
    done[id] = false;
    x = 0;
    sameCycle = false;
}

</declaration>
		<location id="id0" x="-178" y="-136">
			<name x="-161" y="-153">Initial</name>
			<label kind="exponentialrate" x="-188" y="-102">1</label>
			<urgent/>
		</location>
		<location id="id1" x="-178" y="-212">
			<name x="-144" y="-221">PreferencesUpdated</name>
			<label kind="exponentialrate" x="-178" y="-221">1</label>
		</location>
		<location id="id2" x="187" y="-85">
			<name x="204" y="-119">FindingDecisionGroup</name>
			<label kind="exponentialrate" x="187" y="-93">1</label>
		</location>
		<location id="id3" x="187" y="-331">
			<name x="204" y="-357">AwaitingNeighbors</name>
			<label kind="exponentialrate" x="187" y="-340">1</label>
		</location>
		<location id="id4" x="756" y="-331">
			<name x="746" y="-365">Terminal</name>
			<label kind="exponentialrate" x="748" y="-340">1</label>
		</location>
		<init ref="id0"/>
		<transition id="id5">
			<source ref="id1"/>
			<target ref="id1"/>
			<label kind="guard" x="-340" y="-238">!mayContinue</label>
			<label kind="assignment" x="-484" y="-221">mayContinue = compareLevels()</label>
			<nail x="-238" y="-238"/>
			<nail x="-238" y="-187"/>
		</transition>
		<transition id="id6">
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="guard" x="408" y="-348">ND[id] == R</label>
			<label kind="assignment" x="408" y="-331">done[id] = true,
allDone = count(done) == R ? 1 : 0,
sameCycle = allSameTimestamp(cycle)</label>
			<label kind="comments" x="408" y="-272">These updates are only for verification (SMC)</label>
		</transition>
		<transition id="id7">
			<source ref="id3"/>
			<target ref="id3"/>
			<label kind="guard" x="102" y="-416">!mayContinue &amp;&amp; ND[id] != R</label>
			<label kind="assignment" x="110" y="-399">mayContinue = compareCycle()</label>
			<nail x="204" y="-374"/>
			<nail x="170" y="-374"/>
		</transition>
		<transition id="id8">
			<source ref="id3"/>
			<target ref="id1"/>
			<label kind="guard" x="-246" y="-365">mayContinue &amp;&amp; ND[id] != R</label>
			<label kind="assignment" x="-246" y="-348">updateP(),
decision[id] = maxIndex(P),
resetD(),
level[id] = 1,
mayContinue = false</label>
		</transition>
		<transition id="id9">
			<source ref="id2"/>
			<target ref="id3"/>
			<label kind="guard" x="195" y="-289">calm[id] == 3</label>
			<label kind="assignment" x="195" y="-272">ND[id] = count(D[id]),
publicP[id] = P,
mayContinue = false,
incrementCycle()</label>
			<nail x="187" y="-102"/>
		</transition>
		<transition id="id10">
			<source ref="id2"/>
			<target ref="id2"/>
			<label kind="guard" x="187" y="-59">!mayContinue &amp;&amp; calm[id] &lt; 3</label>
			<label kind="assignment" x="187" y="-42">mayContinue = compareLevelsConsenting()</label>
			<nail x="187" y="-17"/>
			<nail x="136" y="-17"/>
			<nail x="136" y="-85"/>
		</transition>
		<transition id="id11">
			<source ref="id2"/>
			<target ref="id2"/>
			<label kind="guard" x="212" y="0">mayContinue &amp;&amp; calm[id] &lt; 3</label>
			<label kind="assignment" x="170" y="17">wasUpdated = !syncWithConsentingNeighbors(),
incrementLevel(),
evaluateCalmness(),
mayContinue = compareLevelsConsenting()</label>
			<nail x="535" y="-85"/>
			<nail x="535" y="17"/>
			<nail x="136" y="17"/>
			<nail x="136" y="-85"/>
		</transition>
		<transition id="id12">
			<source ref="id1"/>
			<target ref="id2"/>
			<label kind="guard" x="8" y="-178">mayContinue</label>
			<label kind="assignment" x="8" y="-161">mayContinue = false</label>
		</transition>
		<transition id="id13">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="assignment" x="-170" y="-170">initialize()</label>
		</transition>
	</template>
	<system>system Robot;
</system>
	<queries>
		<option key="--diagnostic" value="-1"/>
		<query>
			<formula>E[&lt;=1000; 100](max: cyclecounter[0])</formula>
			<comment>How many cycles in total does robot 0 go through before consensus is reached.

Results:
For 7 robots with random preferences in a fully connected graphs. [&lt;=1000;5000] ≈ 2 (as expected)</comment>
			<option key="--exploration" value="0"/>
			<option key="--diagnostic" value="1"/>
			<result outcome="success" type="quantity" value="13.58 ± 1.8332 (95% CI)" timestamp="2025-04-30 12:35:29 +0200">
				<option key="--exploration" value="0"/>
				<option key="--diagnostic" value="1"/>
				<details>13.58 ± 1.8332 (95% CI)</details>
				<plot title="Probability Density Distribution" xaxis="max: cyclecounter[0]" yaxis="probability density">
					<series title="density" type="b(3.000000)" color="0x0000ff" encoding="csv">2.0,0.04
5.0,0.07333333333333333
8.0,0.056666666666666664
11.0,0.02666666666666667
14.0,0.03
17.0,0.02
20.0,0.02666666666666667
23.0,0.01
26.0,0.006666666666666667
29.0,0.02
32.0,0.023333333333333334
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">13.58,0.0
13.58,0.07333333333333333
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=3, bucket count=11
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [2, 33]
Mean estimate of displayed sample: 13.58 ± 1.833 (95% CI)</comment>
				</plot>
				<plot title="Probability Distribution" xaxis="max: cyclecounter[0]" yaxis="probability">
					<series title="probability" type="b(3.000000)" color="0x0000ff" encoding="csv">2.0,0.12
5.0,0.22
8.0,0.17
11.0,0.08
14.0,0.09
17.0,0.06
20.0,0.08
23.0,0.03
26.0,0.02
29.0,0.06
32.0,0.07
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">13.58,0.0
13.58,0.22
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=3, bucket count=11
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [2, 33]
Mean estimate of displayed sample: 13.58 ± 1.833 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Distribution" xaxis="max: cyclecounter[0]" yaxis="probability">
					<series title="cumulative" type="l" color="0x000000" encoding="csv">2.0,0.0
5.0,0.12
8.0,0.34
11.0,0.51
14.0,0.59
17.0,0.68
20.0,0.74
23.0,0.82
26.0,0.85
29.0,0.87
32.0,0.93
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">13.58,0.0
13.58,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=3, bucket count=11
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [2, 33]
Mean estimate of displayed sample: 13.58 ± 1.833 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Confidence Intervals" xaxis="max: cyclecounter[0]" yaxis="probability">
					<series title="upper limit" type="k" color="0x0000dd" encoding="csv">2.0,0.03621669264517642
5.0,0.20023568361996882
8.0,0.4415332677509589
11.0,0.6113558348383622
14.0,0.6873800234324292
17.0,0.769780083238423
20.0,0.8226055621323475
23.0,0.8896887708467395
26.0,0.9135456143583515
29.0,0.9289269538145705
32.0,0.9713947110925613
					</series>
					<series title="lower limit" type="k" color="0xdd0000" encoding="csv">2.0,0.0
5.0,0.0635689025611593
8.0,0.2482235015448442
11.0,0.4080363291554537
14.0,0.48714420376677087
17.0,0.5792331383683774
20.0,0.6426879368998965
23.0,0.7305229140331881
26.0,0.7646924998510451
29.0,0.7879593229125502
32.0,0.8610802715441427
					</series>
					<series title="cumulative" type="l" color="0x000000" encoding="csv">2.0,0.0
5.0,0.12
8.0,0.34
11.0,0.51
14.0,0.59
17.0,0.68
20.0,0.74
23.0,0.82
26.0,0.85
29.0,0.87
32.0,0.93
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">13.58,0.0
13.58,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=3, bucket count=11
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [2, 33]
Mean estimate of displayed sample: 13.58 ± 1.833 (95% CI)</comment>
				</plot>
				<plot title="Frequency Histogram" xaxis="max: cyclecounter[0]" yaxis="count">
					<series title="count" type="b(3.000000)" color="0x0000ff" encoding="csv">2.0,12.0
5.0,22.0
8.0,17.0
11.0,8.0
14.0,9.0
17.0,6.0
20.0,8.0
23.0,3.0
26.0,2.0
29.0,6.0
32.0,7.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">13.58,0.0
13.58,22.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=3, bucket count=11
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [2, 33]
Mean estimate of displayed sample: 13.58 ± 1.833 (95% CI)</comment>
				</plot>
			</result>
		</query>
		<query>
			<formula>E[&lt;=1000; 100](max: x * (allDone ? 0 : 1) )</formula>
			<comment/>
			<result outcome="success" type="quantity" value="493.039 ± 60.3671 (95% CI)" timestamp="2025-04-30 12:35:46 +0200">
				<option key="--diagnostic" value="-1"/>
				<details>493.039 ± 60.3671 (95% CI)</details>
				<plot title="Probability Density Distribution" xaxis="max: x * (allDone ? 0 : 1)" yaxis="probability density">
					<series title="density" type="b(92.704270)" color="0x0000ff" encoding="csv">72.95730059911138,0.0012944387575410635
165.66157053920023,0.0017259183433880848
258.3658404792891,0.00183378823984984
351.07011041937795,7.550892752322871E-4
443.7743803594668,0.0010786989646175528
536.4786502995557,6.472193787705317E-4
629.1829202396445,4.314795858470212E-4
721.8871901797335,6.472193787705317E-4
814.5914601198223,5.393494823087764E-4
907.2957300599111,5.393494823087764E-4
1000.0,0.0012944387575410635
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">493.03869548338514,0.0
493.03869548338514,0.0018337882398498403
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=92.704, bucket count=11
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [72.96, 1000]
Mean estimate of displayed sample: 493 ± 60.37 (95% CI)</comment>
				</plot>
				<plot title="Probability Distribution" xaxis="max: x * (allDone ? 0 : 1)" yaxis="probability">
					<series title="probability" type="b(92.704270)" color="0x0000ff" encoding="csv">72.95730059911138,0.12
165.66157053920023,0.16
258.3658404792891,0.17
351.07011041937795,0.07
443.7743803594668,0.1
536.4786502995557,0.06
629.1829202396445,0.04
721.8871901797335,0.06
814.5914601198223,0.05
907.2957300599111,0.05
1000.0,0.12
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">493.03869548338514,0.0
493.03869548338514,0.17
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=92.704, bucket count=11
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [72.96, 1000]
Mean estimate of displayed sample: 493 ± 60.37 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Distribution" xaxis="max: x * (allDone ? 0 : 1)" yaxis="probability">
					<series title="cumulative" type="l" color="0x000000" encoding="csv">72.95730059911138,0.0
165.66157053920023,0.12
258.3658404792891,0.28
351.07011041937795,0.45
443.7743803594668,0.52
536.4786502995557,0.62
629.1829202396445,0.68
721.8871901797335,0.72
814.5914601198223,0.78
907.2957300599111,0.83
1000.0,0.88
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">493.03869548338514,0.0
493.03869548338514,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=92.704, bucket count=11
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [72.96, 1000]
Mean estimate of displayed sample: 493 ± 60.37 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Confidence Intervals" xaxis="max: x * (allDone ? 0 : 1)" yaxis="probability">
					<series title="upper limit" type="k" color="0x0000dd" encoding="csv">72.95730059911138,0.03621669264517642
165.66157053920023,0.20023568361996882
258.3658404792891,0.3786670047172675
351.07011041937795,0.552719811226064
443.7743803594668,0.6209945198220413
536.4786502995557,0.7152325238585205
629.1829202396445,0.769780083238423
721.8871901797335,0.8052063725088185
814.5914601198223,0.8566964232501856
907.2957300599111,0.8977350899644717
1000.0,0.9364310974388407
					</series>
					<series title="lower limit" type="k" color="0xdd0000" encoding="csv">72.95730059911138,0.0
165.66157053920023,0.0635689025611593
258.3658404792891,0.19479362749118148
351.07011041937795,0.35032022923967204
443.7743803594668,0.4177897654063067
536.4786502995557,0.5174606942491933
629.1829202396445,0.5792331383683774
721.8871901797335,0.6213329952827324
814.5914601198223,0.6860803462136822
907.2957300599111,0.7418245893678413
1000.0,0.7997643163800312
					</series>
					<series title="cumulative" type="l" color="0x000000" encoding="csv">72.95730059911138,0.0
165.66157053920023,0.12
258.3658404792891,0.28
351.07011041937795,0.45
443.7743803594668,0.52
536.4786502995557,0.62
629.1829202396445,0.68
721.8871901797335,0.72
814.5914601198223,0.78
907.2957300599111,0.83
1000.0,0.88
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">493.03869548338514,0.0
493.03869548338514,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=92.704, bucket count=11
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [72.96, 1000]
Mean estimate of displayed sample: 493 ± 60.37 (95% CI)</comment>
				</plot>
				<plot title="Frequency Histogram" xaxis="max: x * (allDone ? 0 : 1)" yaxis="count">
					<series title="count" type="b(92.704270)" color="0x0000ff" encoding="csv">72.95730059911138,12.0
165.66157053920023,16.0
258.3658404792891,17.0
351.07011041937795,7.0
443.7743803594668,10.0
536.4786502995557,6.0
629.1829202396445,4.0
721.8871901797335,6.0
814.5914601198223,5.0
907.2957300599111,5.0
1000.0,12.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">493.03869548338514,0.0
493.03869548338514,17.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=92.704, bucket count=11
Runs: 100 in total, 100 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [72.96, 1000]
Mean estimate of displayed sample: 493 ± 60.37 (95% CI)</comment>
				</plot>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=10000]([] (Robot(0).Terminal &amp;&amp; Robot(1).Terminal &amp;&amp; Robot(2).Terminal &amp;&amp; Robot(3).Terminal &amp;&amp; Robot(4).Terminal &amp;&amp; Robot(5).Terminal &amp;&amp; Robot(6).Terminal ) imply allDone) &gt;= 0.95</formula>
			<comment>Sanity check for 7 robots</comment>
			<result outcome="failure" type="quality" timestamp="2025-04-30 12:35:56 +0200">
				<option key="--diagnostic" value="-1"/>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=10000](&lt;&gt; sameCycle &amp;&amp; allDone)</formula>
			<comment>It would be nice to have the reverse query.
Within this time, how much time does it take at most to reach this state?</comment>
			<option key="--exploration" value="0"/>
			<option key="--diagnostic" value="-1"/>
			<result outcome="success" type="interval" value="≥ 0.950056 (95% CI)" timestamp="2025-04-30 12:36:54 +0200">
				<option key="--exploration" value="0"/>
				<option key="--diagnostic" value="-1"/>
				<details>≥ 0.950056 (95% CI)</details>
				<plot title="Probability Density Distribution" xaxis="run duration in time" yaxis="probability density">
					<series title="density" type="b(251.293958)" color="0x0000ff" encoding="csv">77.91737552378662,0.0017133541872680156
329.2113337462174,0.0013264677578849154
580.5052919686482,2.763474495593574E-4
831.799250191079,3.3161693947122886E-4
1083.0932084135097,1.6580846973561443E-4
1334.3871666359405,5.526948991187147E-5
1585.6811248583713,5.526948991187147E-5
1836.975083080802,0.0
2088.269041303233,5.526948991187147E-5
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">477.0839678890922,0.0
477.0839678890922,0.0017133541872680158
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=251.29, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [77.92, 2340]
Mean estimate of displayed sample: 477.1 ± 94.09 (95% CI)</comment>
				</plot>
				<plot title="Probability Density Confidence Intervals" xaxis="run duration in time" yaxis="probability density">
					<series title="upper limit" type="b(251.293958)" color="0xa0a0ff" encoding="csv">77.91737552378662,0.5526642096839557
329.2113337462174,0.4542961110255666
580.5052919686482,0.15466731481612306
831.799250191079,0.172608584683674
1083.0932084135097,0.11697481982594136
1334.3871666359405,0.07497131085391912
1585.6811248583713,0.07497131085391912
1836.975083080802,0.04994408370585468
2088.269041303233,0.07497131085391912
					</series>
					<series title="lower limit" type="b(251.293958)" color="0x0000ff" encoding="csv">77.91737552378662,0.3143406522440227
329.2113337462174,0.22656342448818495
580.5052919686482,0.022931659153745478
831.799250191079,0.031197509141384482
1083.0932084135097,0.008676497316343764
1334.3871666359405,3.515744052335976E-4
1585.6811248583713,3.515744052335976E-4
1836.975083080802,0.0
2088.269041303233,3.515744052335976E-4
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">477.0839678890922,0.0
477.0839678890922,0.0021992737652481464
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=251.29, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [77.92, 2340]
Mean estimate of displayed sample: 477.1 ± 94.09 (95% CI)</comment>
				</plot>
				<plot title="Probability Distribution" xaxis="run duration in time" yaxis="probability">
					<series title="probability" type="b(251.293958)" color="0x0000ff" encoding="csv">77.91737552378662,0.4305555555555556
329.2113337462174,0.3333333333333333
580.5052919686482,0.06944444444444445
831.799250191079,0.08333333333333333
1083.0932084135097,0.041666666666666664
1334.3871666359405,0.013888888888888888
1585.6811248583713,0.013888888888888888
1836.975083080802,0.0
2088.269041303233,0.013888888888888888
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">477.0839678890922,0.0
477.0839678890922,0.4305555555555556
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=251.29, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [77.92, 2340]
Mean estimate of displayed sample: 477.1 ± 94.09 (95% CI)</comment>
				</plot>
				<plot title="Probability Confidence Intervals" xaxis="run duration in time" yaxis="probability">
					<series title="upper limit" type="b(251.293958)" color="0xa0a0ff" encoding="csv">77.91737552378662,0.5526642096839557
329.2113337462174,0.4542961110255666
580.5052919686482,0.15466731481612306
831.799250191079,0.172608584683674
1083.0932084135097,0.11697481982594136
1334.3871666359405,0.07497131085391912
1585.6811248583713,0.07497131085391912
1836.975083080802,0.04994408370585468
2088.269041303233,0.07497131085391912
					</series>
					<series title="lower limit" type="b(251.293958)" color="0x0000ff" encoding="csv">77.91737552378662,0.3143406522440227
329.2113337462174,0.22656342448818495
580.5052919686482,0.022931659153745478
831.799250191079,0.031197509141384482
1083.0932084135097,0.008676497316343764
1334.3871666359405,3.515744052335976E-4
1585.6811248583713,3.515744052335976E-4
1836.975083080802,0.0
2088.269041303233,3.515744052335976E-4
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">477.0839678890922,0.0
477.0839678890922,0.5526642096839557
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=251.29, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [77.92, 2340]
Mean estimate of displayed sample: 477.1 ± 94.09 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Distribution" xaxis="run duration in time" yaxis="probability">
					<series title="cumulative" type="l" color="0x000000" encoding="csv">77.91737552378662,0.0
329.2113337462174,0.4305555555555556
580.5052919686482,0.7638888888888888
831.799250191079,0.8333333333333334
1083.0932084135097,0.9166666666666666
1334.3871666359405,0.9583333333333334
1585.6811248583713,0.9722222222222222
1836.975083080802,0.9861111111111112
2088.269041303233,0.9861111111111112
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">477.0839678890922,0.0
477.0839678890922,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=251.29, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [77.92, 2340]
Mean estimate of displayed sample: 477.1 ± 94.09 (95% CI)</comment>
				</plot>
				<plot title="Cumulative Probability Confidence Intervals" xaxis="run duration in time" yaxis="probability">
					<series title="upper limit" type="k" color="0x0000dd" encoding="csv">77.91737552378662,0.04994408370585468
329.2113337462174,0.5526642096839557
580.5052919686482,0.8560339363545927
831.799250191079,0.910803593991874
1083.0932084135097,0.9688024908586155
1334.3871666359405,0.9913235026836562
1585.6811248583713,0.9966180996738268
1836.975083080802,0.9996484255947664
2088.269041303233,0.9996484255947664
					</series>
					<series title="lower limit" type="k" color="0xdd0000" encoding="csv">77.91737552378662,0.0
329.2113337462174,0.3143406522440227
580.5052919686482,0.6490999659870761
831.799250191079,0.7269607210880693
1083.0932084135097,0.827391415316326
1334.3871666359405,0.8830251801740586
1585.6811248583713,0.9032327108865847
1836.975083080802,0.9250286891460808
2088.269041303233,0.9250286891460808
					</series>
					<series title="cumulative" type="l" color="0x000000" encoding="csv">77.91737552378662,0.0
329.2113337462174,0.4305555555555556
580.5052919686482,0.7638888888888888
831.799250191079,0.8333333333333334
1083.0932084135097,0.9166666666666666
1334.3871666359405,0.9583333333333334
1585.6811248583713,0.9722222222222222
1836.975083080802,0.9861111111111112
2088.269041303233,0.9861111111111112
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">477.0839678890922,0.0
477.0839678890922,1.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=251.29, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [77.92, 2340]
Mean estimate of displayed sample: 477.1 ± 94.09 (95% CI)</comment>
				</plot>
				<plot title="Frequency Histogram" xaxis="run duration in time" yaxis="count">
					<series title="count" type="b(251.293958)" color="0x0000ff" encoding="csv">77.91737552378662,31.0
329.2113337462174,24.0
580.5052919686482,5.0
831.799250191079,6.0
1083.0932084135097,3.0
1334.3871666359405,1.0
1585.6811248583713,1.0
1836.975083080802,0.0
2088.269041303233,1.0
					</series>
					<series title="average" type="pl" color="0x00dd00" encoding="csv">477.0839678890922,0.0
477.0839678890922,31.0
					</series>
					<comment>Parameters: α=0.05, ε=0.05, bucket width=251.29, bucket count=9
Runs: 72 in total, 72 (100%) displayed, 0 (0%) remaining
Span of displayed sample: [77.92, 2340]
Mean estimate of displayed sample: 477.1 ± 94.09 (95% CI)</comment>
				</plot>
			</result>
		</query>
		<query>
			<formula>Pr[&lt;=20000](&lt;&gt; allDone) &gt;= 0.98</formula>
			<comment/>
			<option key="--search-order" value="2"/>
			<option key="--diagnostic" value="-1"/>
			<result outcome="failure" type="quality" timestamp="2025-04-30 12:37:48 +0200">
				<option key="--search-order" value="2"/>
				<option key="--diagnostic" value="-1"/>
			</result>
		</query>
		<query>
			<formula>Pr[x&lt;=1000](&lt;&gt; Robot(0).Terminal) &gt;= 0.98</formula>
			<comment/>
			<result outcome="failure" type="quality" timestamp="2025-04-30 12:38:11 +0200">
				<option key="--diagnostic" value="-1"/>
			</result>
		</query>
		<query>
			<formula>Pr[x&lt;=1000]([] allDone imply sameCycle) &gt;= 0.98</formula>
			<comment/>
			<option key="--exploration" value="0"/>
			<option key="--diagnostic" value="0"/>
			<result outcome="success" type="quality" timestamp="2025-04-30 11:40:05 +0200">
				<option key="--exploration" value="0"/>
				<option key="--diagnostic" value="0"/>
			</result>
		</query>
		<query>
			<formula>simulate [&lt;=3000; 1000] { ND, cyclecounter } : 1 : x &gt;= 3000 &amp;&amp; !allDone</formula>
			<comment>Counterexamples, should fail</comment>
			<option key="--exploration" value="0"/>
			<option key="--search-order" value="0"/>
			<option key="--diagnostic" value="1"/>
		</query>
		<query>
			<formula>simulate [&lt;=10000; 1000] { cyclecounter } : 1 : x &gt;= 10000 &amp;&amp; !allDone</formula>
			<comment/>
			<result outcome="success" type="quantity" value="0.0645857 ± 0.0639684 (95% CI)" timestamp="2025-04-30 12:38:31 +0200">
				<option key="--diagnostic" value="-1"/>
				<details>0.0645857 ± 0.0639684 (95% CI)</details>
				<plot title="Simulations (1)" xaxis="time" yaxis="value">
					<series title="cyclecounter[0]" type="l" color="0xff0000" encoding="csv">0.0,0.0
14.443061430372966,0.0
14.443061430372966,1.0
31.508784278998963,1.0
31.508784278998963,2.0
52.73935345755825,2.0
52.73935345755825,3.0
123.36044159123205,3.0
123.36044159123205,4.0
151.42503779873533,4.0
151.42503779873533,5.0
187.83527941081528,5.0
187.83527941081528,6.0
217.65209378612772,6.0
217.65209378612772,7.0
10000.0,7.0
					</series>
					<series title="cyclecounter[1]" type="l" color="0xff9900" encoding="csv">0.0,0.0
9.56497554778198,0.0
9.56497554778198,1.0
32.86706363205723,1.0
32.86706363205723,2.0
50.5542087856525,2.0
50.5542087856525,3.0
117.96290140851463,3.0
117.96290140851463,4.0
150.6771772108615,4.0
150.6771772108615,5.0
184.88466754654456,5.0
184.88466754654456,6.0
214.68151011378814,6.0
214.68151011378814,7.0
10000.0,7.0
					</series>
					<series title="cyclecounter[2]" type="l" color="0xccff00" encoding="csv">0.0,0.0
12.560150262300143,0.0
12.560150262300143,1.0
28.71022596264714,1.0
28.71022596264714,2.0
53.438347076719666,2.0
53.438347076719666,3.0
116.56794766358622,3.0
116.56794766358622,4.0
147.11386646683806,4.0
147.11386646683806,5.0
185.878580790306,5.0
185.878580790306,6.0
212.3716071571477,6.0
212.3716071571477,7.0
10000.0,7.0
					</series>
					<series title="cyclecounter[3]" type="l" color="0x33ff00" encoding="csv">0.0,0.0
3.375517398135481,0.0
3.375517398135481,1.0
31.689542154011264,1.0
31.689542154011264,2.0
69.86068973107933,2.0
69.86068973107933,3.0
103.14477965186748,3.0
103.14477965186748,4.0
150.6765625744214,4.0
150.6765625744214,5.0
183.81991293894941,5.0
183.81991293894941,6.0
208.77676120568802,6.0
208.77676120568802,7.0
10000.0,7.0
					</series>
					<series title="cyclecounter[4]" type="l" color="0x00ff66" encoding="csv">0.0,0.0
16.638490419467075,0.0
16.638490419467075,1.0
43.47790459102047,1.0
43.47790459102047,2.0
65.8657916281883,2.0
65.8657916281883,3.0
103.42837313561732,3.0
103.42837313561732,4.0
153.0313300878331,4.0
153.0313300878331,5.0
182.01517446001998,5.0
182.01517446001998,6.0
211.45230528951544,6.0
211.45230528951544,7.0
10000.0,7.0
					</series>
					<series title="cyclecounter[5]" type="l" color="0x00ffff" encoding="csv">0.0,0.0
13.088185023194391,0.0
13.088185023194391,1.0
44.54864175592867,1.0
44.54864175592867,2.0
68.66482421900392,2.0
68.66482421900392,3.0
105.85137977951828,3.0
105.85137977951828,4.0
147.73352877576238,4.0
147.73352877576238,5.0
185.01552825392622,5.0
185.01552825392622,6.0
217.49294984567123,6.0
217.49294984567123,7.0
10000.0,7.0
					</series>
					<series title="cyclecounter[6]" type="l" color="0x0066ff" encoding="csv">0.0,0.0
17.238190681392606,0.0
17.238190681392606,1.0
46.00000504638542,1.0
46.00000504638542,2.0
70.4352818044828,2.0
70.4352818044828,3.0
107.73131897315434,3.0
107.73131897315434,4.0
150.45558923761624,4.0
150.45558923761624,5.0
178.72815418803708,5.0
178.72815418803708,6.0
218.54601262711432,6.0
218.54601262711432,7.0
10000.0,7.0
					</series>
					<series title="cyclecounter[7]" type="l" color="0x3300ff" encoding="csv">0.0,0.0
6.1467970825383995,0.0
6.1467970825383995,1.0
29.185530465281953,1.0
29.185530465281953,2.0
73.74156424179311,2.0
73.74156424179311,3.0
109.66864889532403,3.0
109.66864889532403,4.0
152.6030578593056,4.0
152.6030578593056,5.0
182.1714255359161,5.0
182.1714255359161,6.0
218.39061501183215,6.0
218.39061501183215,7.0
10000.0,7.0
					</series>
					<series title="cyclecounter[8]" type="l" color="0xcc00ff" encoding="csv">0.0,0.0
5.243439454748079,0.0
5.243439454748079,1.0
39.208800192337876,1.0
39.208800192337876,2.0
51.578583666571504,2.0
51.578583666571504,3.0
87.85478705168336,3.0
87.85478705168336,4.0
151.20249842972558,4.0
151.20249842972558,5.0
182.89097543325784,5.0
182.89097543325784,6.0
207.55686340922847,6.0
207.55686340922847,7.0
10000.0,7.0
					</series>
					<series title="cyclecounter[9]" type="l" color="0xff0099" encoding="csv">0.0,0.0
6.111544957425998,0.0
6.111544957425998,1.0
36.05531980351559,1.0
36.05531980351559,2.0
57.447127468553944,2.0
57.447127468553944,3.0
90.0666063207568,3.0
90.0666063207568,4.0
120.75649371334866,4.0
120.75649371334866,5.0
159.5978464885652,5.0
159.5978464885652,6.0
213.86062332384233,6.0
213.86062332384233,7.0
10000.0,7.0
					</series>
					<comment/>
				</plot>
			</result>
		</query>
		<query>
			<formula>simulate [&lt;=3000; 10000] { cyclecounter[0], allDone * 100 }</formula>
			<comment/>
		</query>
	</queries>
</nta>
