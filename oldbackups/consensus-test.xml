<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// Place global declarations here.

// ================================================
// Constants and type definition

const int R = 3;                // Number of robots
typedef int[0,R-1] robot;         // The set of robot ids
typedef int[-1,R-1] optionalRobot;// The set of robot ids, -1 denoting null


const int Q = 2;                // Number of choices
const int q = Q-1;              // Final choice index
typedef int[0,q] choice;           // The set of choice indexes
typedef int[-1,q] optionalChoice;       // The set of choice indexes

const int NN = 2;               // Max number of neighbors
const int nn = NN-1;
typedef int[0,nn] neighbor;          // The set of possible neighbor indexes
typedef int[-1,nn] optionalNeighbor; // The set of possible neighbor indexes, -1 denoting null

// ================================================
// Communication

broadcast chan decisionMade[R]; // This robot has made a decision
choice decisionMadeVar;         // The decision the robot made

broadcast chan agree[R];        // A robot agrees with this robot
bool agreeVar[R];               // The consensus group of the agreeing robot

broadcast chan disagree[R];     // A robot disagrees with this robot

// =================================================
// Functions

// Populate array with random values summing to 1 (PMF)
void initP(double &amp;P[Q]){
    double rands[Q];
    double ssum = 0;
    for (i : choice) {
        double val = random(1);
        rands[i] = val;
        ssum = ssum + val;
    }
    for (i : choice) {
        P[i] = rands[i] / ssum;
    }
}

// Count the number of true values in array
int[0,R] count(bool A[R]){
    return sum (i : robot) A[i] == true;
}

// Get the index of a highest value
choice maxIndex(double &amp;P[Q]){
    choice maxI = 0;
    double max = 0;
    for (i : choice){
        if (P[i] &gt; max) {
            max = P[i];
            maxI = i;
        }
    }
    return maxI;
}

// Get next true value of boolean array starting at index i.
// Returns -1 if there is no next value
optionalRobot getNextTru(int i, bool &amp;A[R]){
    for (i : robot) {
        if (A[i]) return i;
    }
    return -1;
}

// ===============================================
// Currently unused

// Get the index containing a minimum value
int minIndex(int &amp;P[R]){
    robot minI = 0;
    double min = 0;
    for (i : choice){
        if (P[i] &lt; min) {
            min = P[i];
            minI = i;
        }
    }
    return minI;
}

// Makes array A into the union of A and B
void inPlaceUnion(bool A[R], bool B[R]) {
    for (i : robot) {A[i] = A[i] || B[i];}
}</declaration>
	<template>
		<name>Robot</name>
		<parameter>robot id, bool &amp;C[R]</parameter>
		<declaration>// =====================================================
// Clocks

clock timeout;

// =====================================================
// State

// Arrays of all robot ids
// robot id                         // id of this robot
// bool C[R]                        // Connection group (Neighbors)
int[0,NN] NC;                       // Size of C (should be within NN)
optionalNeighbor neighborIndex[R];  // The index of each neighbor in the neighbor arrays. -1 for non
bool D[R];                          // Local consensus group
int[0,R] ND;                        // Size of D

// Neighbor arrays
optionalRobot neighbors[NN];   // Inverted index of neighbors, index 0 to NC-1 contains index of true values in C
optionalChoice neighborDecision[NN];   // The choices of each neighbor as understood by this robot.

double P[Q];               // Preferences
optionalChoice decision;           // Exhibited decision (max of P)
choice newDecision;

int[0,NN] acknowledgements; // Temporary variable counting how many neighbors have received message
robot partner;              // Temporary variable denoting the current communication partner's
choice partnerDecision;     // Temporary variable denoting the current communication partner's choice

// =====================================================
// Methods
// Functions that are simplified by having access to state

void joinGroup(bool &amp;A[R]) {
    for (i : robot) {D[i] = D[i] || A[i];}
}

void resetD() {
    for (i : robot) { D[i] = false; }
    D[id] = true;
}

// Get next true value of boolean array starting at index i.
// Returns -1 if there is no next value
optionalRobot getNextTrue(int i, bool &amp;A[R]){
    for (i : robot) {
        if (A[i]) return i;
    }
    return -1;
}

// Create inverted Index of neighbors
void initNeighbors() {
    robot Ci = 0;
    optionalNeighbor i = -1;

    Ci = getNextTrue(0, C);
    for (n : neighbor) {
        neighbors[n] = -1;
        neighborDecision[n] = -1;
    }
    for (r : robot) {
        neighborIndex[r] = -1;
    }
    while (Ci != -1 &amp;&amp; i &lt; NN-1) {
        i++;
        neighborIndex[Ci] = i;
        neighbors[i] = Ci;
        Ci = getNextTrue(Ci, C);
    }
}

void initialize() {
    NC = count(C);
    initP(P);
    initNeighbors();
    decision = -1;
}</declaration>
		<location id="id0" x="-340" y="-297">
			<name x="-350" y="-331">initial</name>
			<committed/>
		</location>
		<location id="id1" x="-68" y="-195">
			<name x="-51" y="-220">decide</name>
			<urgent/>
		</location>
		<location id="id2" x="-68" y="-348">
			<name x="-59" y="-382">updatePreferences</name>
		</location>
		<location id="id3" x="-68" y="-17">
			<name x="-59" y="-51">informCofDecision</name>
			<label kind="exponentialrate" x="-85" y="-51">1</label>
		</location>
		<location id="id4" x="297" y="-17">
			<name x="314" y="-51">emitD</name>
		</location>
		<location id="id5" x="238" y="119">
			<name x="247" y="93">acknowledgeDecision</name>
			<committed/>
		</location>
		<location id="id6" x="76" y="331">
			<name x="16" y="305">IAgree</name>
			<committed/>
		</location>
		<location id="id7" x="136" y="314">
			<name x="145" y="279">IDisagree</name>
			<committed/>
		</location>
		<location id="id8" x="-68" y="-297">
			<name x="-51" y="-305">prefsUpdated</name>
			<urgent/>
		</location>
		<location id="id9" x="238" y="425">
			<name x="228" y="391">decisionAcknowledged</name>
			<committed/>
		</location>
		<location id="id10" x="357" y="221">
			<name x="347" y="187">IDontCare</name>
			<committed/>
		</location>
		<location id="id11" x="76" y="212">
			<name x="66" y="178">ICare</name>
			<committed/>
		</location>
		<init ref="id0"/>
		<transition id="id12">
			<source ref="id11"/>
			<target ref="id7"/>
			<label kind="guard" x="102" y="238">partnerDecision != decision</label>
			<label kind="synchronisation" x="136" y="255">disagree[partner]!</label>
		</transition>
		<transition id="id13">
			<source ref="id10"/>
			<target ref="id9"/>
		</transition>
		<transition id="id14">
			<source ref="id5"/>
			<target ref="id10"/>
			<label kind="guard" x="289" y="136">neighborDecision[neighborIndex[partner]] == partnerDecision</label>
		</transition>
		<transition id="id15">
			<source ref="id9"/>
			<target ref="id3"/>
			<label kind="guard" x="-721" y="259">acknowledgements &lt; NC</label>
			<nail x="-739" y="289"/>
			<nail x="-739" y="-17"/>
		</transition>
		<transition id="id16">
			<source ref="id7"/>
			<target ref="id9"/>
		</transition>
		<transition id="id17">
			<source ref="id6"/>
			<target ref="id9"/>
		</transition>
		<transition id="id18">
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="guard" x="59" y="-34">acknowledgements == NC</label>
			<nail x="-34" y="-34"/>
			<nail x="246" y="-34"/>
		</transition>
		<transition id="id19">
			<source ref="id2"/>
			<target ref="id8"/>
		</transition>
		<transition id="id20">
			<source ref="id3"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-603" y="-8">agree[id]?</label>
			<label kind="assignment" x="-688" y="8">joinGroup(agreeVar),
acknowledgements++</label>
			<nail x="-68" y="76"/>
			<nail x="-510" y="76"/>
			<nail x="-510" y="-17"/>
		</transition>
		<transition id="id21">
			<source ref="id3"/>
			<target ref="id3"/>
			<label kind="synchronisation" x="-450" y="-8">disagree[id]?</label>
			<label kind="assignment" x="-493" y="8">acknowledgements++</label>
			<nail x="-68" y="76"/>
			<nail x="-331" y="76"/>
			<nail x="-331" y="-17"/>
		</transition>
		<transition id="id22">
			<source ref="id3"/>
			<target ref="id3"/>
			<label kind="guard" x="-289" y="-8">acknowledgements &lt; NC</label>
			<label kind="synchronisation" x="-255" y="8">decisionMade[id]!</label>
			<label kind="assignment" x="-331" y="25">decisionMadeVar = decision</label>
			<nail x="-68" y="76"/>
			<nail x="-102" y="76"/>
			<nail x="-102" y="-17"/>
		</transition>
		<transition id="id23">
			<source ref="id5"/>
			<target ref="id11"/>
			<label kind="guard" x="-331" y="136">neighborDecision[neighborIndex[partner]] != partnerDecision</label>
			<label kind="assignment" x="-365" y="153">neighborDecision[neighborIndex[partner]] = partnerDecision</label>
		</transition>
		<transition id="id24">
			<source ref="id11"/>
			<target ref="id6"/>
			<label kind="guard" x="-170" y="246">partnerDecision == decision</label>
			<label kind="synchronisation" x="-59" y="263">agree[partner]!</label>
			<label kind="assignment" x="-84" y="280">D[partner] = true,
agreeVar = D</label>
		</transition>
		<transition id="id25">
			<source ref="id3"/>
			<target ref="id5"/>
			<label kind="select" x="-42" y="8">r : robot</label>
			<label kind="guard" x="-42" y="25">C[r] == true</label>
			<label kind="synchronisation" x="-42" y="42">decisionMade[r]?</label>
			<label kind="assignment" x="-42" y="59">partner = r,
partnerDecision = decisionMadeVar</label>
			<nail x="-68" y="119"/>
		</transition>
		<transition id="id26">
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="guard" x="119" y="-17">timeout &gt;= 10</label>
			<nail x="-25" y="0"/>
			<nail x="246" y="0"/>
		</transition>
		<transition id="id27">
			<source ref="id4"/>
			<target ref="id2"/>
			<nail x="425" y="-17"/>
			<nail x="425" y="-348"/>
		</transition>
		<transition id="id28">
			<source ref="id1"/>
			<target ref="id4"/>
			<label kind="guard" x="34" y="-220">decision == newDecision</label>
			<nail x="297" y="-195"/>
		</transition>
		<transition id="id29">
			<source ref="id8"/>
			<target ref="id1"/>
			<label kind="assignment" x="-59" y="-263">newDecision = maxIndex(P)</label>
		</transition>
		<transition id="id30">
			<source ref="id1"/>
			<target ref="id3"/>
			<label kind="guard" x="-263" y="-152">decision != newDecision</label>
			<label kind="assignment" x="-59" y="-178">timeout = 0,
acknowledgements = 0,
decision = newDecision,
resetD()</label>
		</transition>
		<transition id="id31">
			<source ref="id0"/>
			<target ref="id8"/>
			<label kind="assignment" x="-323" y="-289">initialize()</label>
		</transition>
	</template>
	<system>// Place template instantiations here.

/* For R = 5

bool c5_0[R] = {false, true, true,  false, false },
bool c5_1[R] = {true,  false, false, true,  false },
bool c5_2[R] = {true,  false, false, false, false },
bool c5_3[R] = {false, true,  false, false, true  },
bool c5_4[R] = {false, false, false, true,  false }

r0 = Robot(0, c5_0);
r1 = Robot(1, c5_1);
r2 = Robot(2, c5_2);
r3 = Robot(3, c5_3);
r4 = Robot(4, c5_4);

*/

/* For R = 3 */

bool c3_0[R] = {false, true,  true  };
bool c3_1[R] = {true,  false, false };
bool c3_2[R] = {true,  false, false };

r0 = Robot(0, c3_0);
r1 = Robot(1, c3_1);
r2 = Robot(2, c3_2);

// List one or more processes to be composed into a system.
system r0, r1, r2;</system>
	<queries>
		<option key="--diagnostic" value="1"/>
		<query>
			<formula/>
			<comment/>
		</query>
	</queries>
</nta>
