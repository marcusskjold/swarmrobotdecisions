<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.6//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_6.dtd'>
<nta>
	<declaration>// Place global declarations here.

// ================================================
// Constants and type definition

const int R = 7;                     // Number of robots
typedef int[0,R-1] robot;            // The set of robot ids
typedef int[-1,R-1] optionalRobot;   // The set of robot ids, -1 denoting null

const int Q = 1;                     // Number of choices
const int q = Q-1;                   // Final choice index
typedef int[0,q] choice;             // The set of choice indexes
typedef int[-1,q] optionalChoice;    // The set of choice indexes

const int NN = 6;                    // Max number of neighbors
const int nn = NN-1;
typedef int[0,nn] neighbor;          // The set of possible neighbor indexes
typedef int[-1,nn] optionalNeighbor; // The set of possible neighbor indexes, -1 denoting null

typedef int[0,2] timestamp;
typedef int[0,2] calmness;

// ================================================
// Robot state

bool D[R][R];
double P[R][Q];
int[0,NN] NC[R];
int[0,R] ND[R];
choice decision[R];

// Locking state
timestamp timestamps[R];
int[0,R] level[R];
calmness calm[R];
// bool Dbuffer[R][R];



// ================================================
// Communication

// broadcast chan decisionMade[R]; // This robot has made a decision
// choice decisionMadeVar;         // The decision the robot made

// broadcast chan agree[R];        // A robot agrees with this robot
// bool agreeVar[R];               // The consensus group of the agreeing robot

// broadcast chan disagree[R];     // A robot disagrees with this robot

// =================================================
// Functions

bool compareTimestamp(timestamp a, timestamp b) {
    if (a == b) return true;
    if ((a + 1) % 3 == b) return true;
    return false;
}

// Populate array with random values summing to 1 (PMF)
void initP(double &amp;P[Q]){
    double rands[Q];
    double ssum = 0;
    for (i : choice) {
        double val = random(1);
        rands[i] = val;
        ssum = ssum + val;
    }
    for (i : choice) {
        P[i] = rands[i] / ssum;
    }
}

// Count the number of true values in array
int[0,R] count(bool A[R]){
    return sum (i : robot) A[i] == true;
}

// Get the index of a highest value
choice maxIndex(double &amp;P[Q]){
    choice maxI = 0;
    double max = 0;
    for (i : choice){
        if (P[i] &gt; max) {
            max = P[i];
            maxI = i;
        }
    }
    return maxI;
}

// Get next true value of boolean array starting at index i.
// Returns -1 if there is no next value
optionalRobot getNextTrue(int i, bool &amp;A[R]){
    while (i &lt; R-1) {
        i++;
        if (A[i]) return i;
        
    }
    return -1;
}


// ===============================================
// Currently unused

// Get the index containing a minimum value
int minIndex(int &amp;P[R]){
    robot minI = 0;
    double min = 0;
    for (i : choice){
        if (P[i] &lt; min) {
            min = P[i];
            minI = i;
        }
    }
    return minI;
}

// Makes array A into the union of A and B
void inPlaceUnion(bool A[R], bool B[R]) {
    for (i : robot) {A[i] = A[i] || B[i];}
}</declaration>
	<template>
		<name>Robot</name>
		<parameter>robot id, bool &amp;C[R]</parameter>
		<declaration>// =====================================================
// Clocks

// clock timeout;

// =====================================================
// State

// Arrays of all robot ids
// robot id                         // id of this robot
// bool C[R]                        // Connection group (Neighbors)
// int[0,NN] NC;                       // Size of C (should be within NN)
// optionalNeighbor neighborIndex[R];  // The index of each neighbor in the neighbor arrays. -1 for non
// bool D[R];                          // Local consensus group
// int[0,R] ND;                        // Size of D

// Neighbor arrays
optionalRobot neighbors[NN];           // Inverted index of neighbors, index 0 to NC-1 contains index of true values in C. -1 for empty slots.
// optionalChoice neighborDecision[NN];   // The choices of each neighbor as understood by this robot.

// double P[Q];               // Preferences
// optionalChoice decision;           // Exhibited decision (max of P)
// choice newDecision;

// int[0,NN] acknowledgements; // Temporary variable counting how many neighbors have received message
// robot partner;              // Temporary variable denoting the current communication partner's
// choice partnerDecision;     // Temporary variable denoting the current communication partner's choice

bool mayContinue;

// =====================================================
// Methods
// Functions that are simplified by having access to state

bool joinGroup(bool &amp;A[R], bool &amp;B[R]) {
    bool stale = true;
    for (i : robot) {
        stale = stale &amp;&amp; (A[i] == B[i]);
        A[i] = B[i] || A[i];
    }
    return stale;
}

bool syncWithConsentingNeighbors() {
    bool stale = true;
    optionalRobot neigh;
    for (n : neighbor) {
        neigh = neighbors[n];
        if (neigh != -1 &amp;&amp; decision[neigh] == decision[id]) {
            for (i : robot) {
                stale &amp;= (D[neigh][i] imply D[id][i]);
                D[id][i] = D[neigh][i] || D[id][i];
            }
        }
    }
    return stale;
}

bool syncWithConsentingNeighborsBAK() {
    bool stale = true;
    for (n : neighbor) {
        if (neighbors[n] != -1 &amp;&amp; decision[neighbors[n]] == decision[id]) {
            stale = stale &amp;&amp; joinGroup(D[id], D[neighbors[n]]);
        }
    }
    return stale;
}

bool neighborsCalm() {
    bool allCalm = true;
    for (n : neighbor) {
        if (neighbors[n] != -1 &amp;&amp; decision[neighbors[n]] == decision[id]) {
            allCalm = allCalm &amp;&amp; (calm[neighbors[n]] &gt; 0);
        }
    }
    return allCalm;
}

bool compareLevels() {
    for (n : neighbor) {
        if (neighbors[n] != -1 &amp;&amp; decision[neighbors[n]] == decision[id]) {
            if (level[neighbors[n]] &lt; level[id]) { return false; }
        }
    }
    return true;
}

void resetD() {
    for (i : robot) { D[id][i] = C[i] &amp;&amp; decision[id]; }
    D[id][id] = true;
}

// Create inverted Index of neighbors
void initNeighbors() {
    optionalRobot Ci;
    optionalNeighbor i = -1;

    Ci = getNextTrue(-1, C);
    for (n : neighbor) {
        neighbors[n] = -1;
    }

    while (Ci != -1 &amp;&amp; i &lt; NN-1) {
        i++;
        neighbors[i] = Ci;
        Ci = getNextTrue(Ci, C);
    }
}

// Initialize a robot
void initialize() {
    NC[id] = count(C);
    for (pref : choice) {
        P[id][pref] = 0;
    }
    P[id][0] = 1;
    // initP(P[id]);
    decision[id] = maxIndex(P[id]);
}</declaration>
		<location id="id0" x="-272" y="-85">
			<name x="-255" y="-102">initial</name>
			<committed/>
		</location>
		<location id="id1" x="-102" y="-85">
			<name x="-93" y="-119">readNeighbors</name>
		</location>
		<location id="id2" x="187" y="-85">
			<name x="34" y="-110">calculateDsize</name>
			<label kind="invariant" x="195" y="-85">level[id] &lt;= R-1</label>
		</location>
		<location id="id3" x="654" y="-85">
			<name x="663" y="-119">final</name>
		</location>
		<init ref="id0"/>
		<transition id="id4">
			<source ref="id2"/>
			<target ref="id2"/>
			<label kind="guard" x="135" y="-272">calm[id] == 1</label>
			<label kind="assignment" x="59" y="-255">calm[id] = neighborsCalm() ? 2 : 1</label>
			<nail x="348" y="-229"/>
			<nail x="25" y="-229"/>
		</transition>
		<transition id="id5">
			<source ref="id2"/>
			<target ref="id3"/>
			<label kind="guard" x="306" y="-110">level[id] == R-1 || calm[id] == 2</label>
			<label kind="assignment" x="382" y="-76">ND[id] = count(D[id])</label>
		</transition>
		<transition id="id6">
			<source ref="id2"/>
			<target ref="id2"/>
			<label kind="guard" x="59" y="59">!mayContinue &amp;&amp; calm[id] &lt; 2</label>
			<label kind="assignment" x="59" y="76">mayContinue = compareLevels()</label>
			<nail x="212" y="60"/>
			<nail x="153" y="60"/>
		</transition>
		<transition id="id7">
			<source ref="id2"/>
			<target ref="id2"/>
			<label kind="guard" x="340" y="85">mayContinue &amp;&amp; calm[id] &lt; 2</label>
			<label kind="assignment" x="-1" y="161">calm[id] = syncWithConsentingNeighbors() ? 1 : 0,
level[id]++,
mayContinue = compareLevels()</label>
			<nail x="365" y="152"/>
			<nail x="0" y="153"/>
		</transition>
		<transition id="id8">
			<source ref="id1"/>
			<target ref="id2"/>
			<label kind="assignment" x="-102" y="-221">resetD(),
calm[id] = 0,
level[id] = 1,
mayContinue = false,
syncWithConsentingNeighbors()</label>
		</transition>
		<transition id="id9">
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="assignment" x="-272" y="-170">initialize(),
initNeighbors(),
level[id] = 0</label>
		</transition>
	</template>
	<system>// Place template instantiations here.

/* For R = 5

bool c5_0[R] = {false, true, true,  false, false },
bool c5_1[R] = {true,  false, false, true,  false },
bool c5_2[R] = {true,  false, false, false, false },
bool c5_3[R] = {false, true,  false, false, true  },
bool c5_4[R] = {false, false, false, true,  false }

r0 = Robot(0, c5_0);
r1 = Robot(1, c5_1);
r2 = Robot(2, c5_2);
r3 = Robot(3, c5_3);
r4 = Robot(4, c5_4);

*/

/* For R = 3 */

/*
bool c3_0[R] = {false, true,  true  };
bool c3_1[R] = {true,  false, false };
bool c3_2[R] = {true,  false, false };

r0 = Robot(0, c3_0);
r1 = Robot(1, c3_1);
r2 = Robot(2, c3_2);

system r0, r1, r2;
*/

bool c5_0[R] = {false, true, true, true, true, true, true};
bool c5_1[R] = {true, false, true, true, true, true, true};
bool c5_2[R] = {true, true, false, true, true, true, true};
bool c5_3[R] = {true, true, true, false, true, true, true};
bool c5_4[R] = {true, true, true, true, false, true, true};
bool c5_5[R] = {true, true, true, true, true, false, true};
bool c5_6[R] = {true, true, true, true, true, true, false};
r0 = Robot(0, c5_0);
r1 = Robot(1, c5_1);
r2 = Robot(2, c5_2);
r3 = Robot(3, c5_3);
r4 = Robot(4, c5_4);
r5 = Robot(5, c5_5);
r6 = Robot(6, c5_6);
system r0, r1, r2, r3, r4, r5, r6;</system>
	<queries>
		<option key="--diagnostic" value="1"/>
		<query>
			<formula/>
			<comment/>
		</query>
	</queries>
</nta>
